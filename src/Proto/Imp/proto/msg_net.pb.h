// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/msg_net.proto

#ifndef PROTOBUF_proto_2fmsg_5fnet_2eproto__INCLUDED
#define PROTOBUF_proto_2fmsg_5fnet_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_proto_2fmsg_5fnet_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[44];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsStringNetImpl();
void InitDefaultsStringNet();
void InitDefaultsUint32NetImpl();
void InitDefaultsUint32Net();
void InitDefaultsUint32ListNetImpl();
void InitDefaultsUint32ListNet();
void InitDefaultsUint64NetImpl();
void InitDefaultsUint64Net();
void InitDefaultsDoubleInt32NetImpl();
void InitDefaultsDoubleInt32Net();
void InitDefaultsDoubleUint64NetImpl();
void InitDefaultsDoubleUint64Net();
void InitDefaultsServerInfoImpl();
void InitDefaultsServerInfo();
void InitDefaultsMapPosImpl();
void InitDefaultsMapPos();
void InitDefaultsPlayerBaseInfoImpl();
void InitDefaultsPlayerBaseInfo();
void InitDefaultsRoleBaseInfoImpl();
void InitDefaultsRoleBaseInfo();
void InitDefaultsItemBaseInfoImpl();
void InitDefaultsItemBaseInfo();
void InitDefaultsItemInfoImpl();
void InitDefaultsItemInfo();
void InitDefaultsItemChangeInfoImpl();
void InitDefaultsItemChangeInfo();
void InitDefaultsItemBagImpl();
void InitDefaultsItemBag();
void InitDefaultsEquipBaseInfoImpl();
void InitDefaultsEquipBaseInfo();
void InitDefaultsEquipInfoImpl();
void InitDefaultsEquipInfo();
void InitDefaultsEquipChangeInfoImpl();
void InitDefaultsEquipChangeInfo();
void InitDefaultsEquipBagImpl();
void InitDefaultsEquipBag();
void InitDefaultsRoleInfoImpl();
void InitDefaultsRoleInfo();
void InitDefaultsLoginReqNetImpl();
void InitDefaultsLoginReqNet();
void InitDefaultsLoginRspNetImpl();
void InitDefaultsLoginRspNet();
void InitDefaultsSelectGameServerReqNetImpl();
void InitDefaultsSelectGameServerReqNet();
void InitDefaultsSelectGameServerRspNetImpl();
void InitDefaultsSelectGameServerRspNet();
void InitDefaultsLoginGameReqNetImpl();
void InitDefaultsLoginGameReqNet();
void InitDefaultsLoginGameRspNetImpl();
void InitDefaultsLoginGameRspNet();
void InitDefaultsCreateRoleReqNetImpl();
void InitDefaultsCreateRoleReqNet();
void InitDefaultsCreateRoleRspNetImpl();
void InitDefaultsCreateRoleRspNet();
void InitDefaultsEnterSceneReqNetImpl();
void InitDefaultsEnterSceneReqNet();
void InitDefaultsEnterSceneRspNetImpl();
void InitDefaultsEnterSceneRspNet();
void InitDefaultsBagNotifyNetImpl();
void InitDefaultsBagNotifyNet();
void InitDefaultsEquipBagNotifyNetImpl();
void InitDefaultsEquipBagNotifyNet();
void InitDefaultsErrorNotifyNetImpl();
void InitDefaultsErrorNotifyNet();
void InitDefaultsUpdLoginReqNetImpl();
void InitDefaultsUpdLoginReqNet();
void InitDefaultsUpdLoginRspNetImpl();
void InitDefaultsUpdLoginRspNet();
void InitDefaultsUpdTestReqNetImpl();
void InitDefaultsUpdTestReqNet();
void InitDefaultsUpdTestRspNetImpl();
void InitDefaultsUpdTestRspNet();
void InitDefaultsBuyRoleSoltReqNetImpl();
void InitDefaultsBuyRoleSoltReqNet();
void InitDefaultsBuyRoleSoltRspNetImpl();
void InitDefaultsBuyRoleSoltRspNet();
void InitDefaultsGMCMDReqNetImpl();
void InitDefaultsGMCMDReqNet();
void InitDefaultsGMCMDRspNetImpl();
void InitDefaultsGMCMDRspNet();
void InitDefaultsItemChangeNotifyNetImpl();
void InitDefaultsItemChangeNotifyNet();
void InitDefaultsEquipChangeNotifyNetImpl();
void InitDefaultsEquipChangeNotifyNet();
void InitDefaultsBuyBagSoltReqNetImpl();
void InitDefaultsBuyBagSoltReqNet();
void InitDefaultsBuyBagSoltRspNetImpl();
void InitDefaultsBuyBagSoltRspNet();
inline void InitDefaults() {
  InitDefaultsStringNet();
  InitDefaultsUint32Net();
  InitDefaultsUint32ListNet();
  InitDefaultsUint64Net();
  InitDefaultsDoubleInt32Net();
  InitDefaultsDoubleUint64Net();
  InitDefaultsServerInfo();
  InitDefaultsMapPos();
  InitDefaultsPlayerBaseInfo();
  InitDefaultsRoleBaseInfo();
  InitDefaultsItemBaseInfo();
  InitDefaultsItemInfo();
  InitDefaultsItemChangeInfo();
  InitDefaultsItemBag();
  InitDefaultsEquipBaseInfo();
  InitDefaultsEquipInfo();
  InitDefaultsEquipChangeInfo();
  InitDefaultsEquipBag();
  InitDefaultsRoleInfo();
  InitDefaultsLoginReqNet();
  InitDefaultsLoginRspNet();
  InitDefaultsSelectGameServerReqNet();
  InitDefaultsSelectGameServerRspNet();
  InitDefaultsLoginGameReqNet();
  InitDefaultsLoginGameRspNet();
  InitDefaultsCreateRoleReqNet();
  InitDefaultsCreateRoleRspNet();
  InitDefaultsEnterSceneReqNet();
  InitDefaultsEnterSceneRspNet();
  InitDefaultsBagNotifyNet();
  InitDefaultsEquipBagNotifyNet();
  InitDefaultsErrorNotifyNet();
  InitDefaultsUpdLoginReqNet();
  InitDefaultsUpdLoginRspNet();
  InitDefaultsUpdTestReqNet();
  InitDefaultsUpdTestRspNet();
  InitDefaultsBuyRoleSoltReqNet();
  InitDefaultsBuyRoleSoltRspNet();
  InitDefaultsGMCMDReqNet();
  InitDefaultsGMCMDRspNet();
  InitDefaultsItemChangeNotifyNet();
  InitDefaultsEquipChangeNotifyNet();
  InitDefaultsBuyBagSoltReqNet();
  InitDefaultsBuyBagSoltRspNet();
}
}  // namespace protobuf_proto_2fmsg_5fnet_2eproto
namespace protocol {
class BagNotifyNet;
class BagNotifyNetDefaultTypeInternal;
extern BagNotifyNetDefaultTypeInternal _BagNotifyNet_default_instance_;
class BuyBagSoltReqNet;
class BuyBagSoltReqNetDefaultTypeInternal;
extern BuyBagSoltReqNetDefaultTypeInternal _BuyBagSoltReqNet_default_instance_;
class BuyBagSoltRspNet;
class BuyBagSoltRspNetDefaultTypeInternal;
extern BuyBagSoltRspNetDefaultTypeInternal _BuyBagSoltRspNet_default_instance_;
class BuyRoleSoltReqNet;
class BuyRoleSoltReqNetDefaultTypeInternal;
extern BuyRoleSoltReqNetDefaultTypeInternal _BuyRoleSoltReqNet_default_instance_;
class BuyRoleSoltRspNet;
class BuyRoleSoltRspNetDefaultTypeInternal;
extern BuyRoleSoltRspNetDefaultTypeInternal _BuyRoleSoltRspNet_default_instance_;
class CreateRoleReqNet;
class CreateRoleReqNetDefaultTypeInternal;
extern CreateRoleReqNetDefaultTypeInternal _CreateRoleReqNet_default_instance_;
class CreateRoleRspNet;
class CreateRoleRspNetDefaultTypeInternal;
extern CreateRoleRspNetDefaultTypeInternal _CreateRoleRspNet_default_instance_;
class DoubleInt32Net;
class DoubleInt32NetDefaultTypeInternal;
extern DoubleInt32NetDefaultTypeInternal _DoubleInt32Net_default_instance_;
class DoubleUint64Net;
class DoubleUint64NetDefaultTypeInternal;
extern DoubleUint64NetDefaultTypeInternal _DoubleUint64Net_default_instance_;
class EnterSceneReqNet;
class EnterSceneReqNetDefaultTypeInternal;
extern EnterSceneReqNetDefaultTypeInternal _EnterSceneReqNet_default_instance_;
class EnterSceneRspNet;
class EnterSceneRspNetDefaultTypeInternal;
extern EnterSceneRspNetDefaultTypeInternal _EnterSceneRspNet_default_instance_;
class EquipBag;
class EquipBagDefaultTypeInternal;
extern EquipBagDefaultTypeInternal _EquipBag_default_instance_;
class EquipBagNotifyNet;
class EquipBagNotifyNetDefaultTypeInternal;
extern EquipBagNotifyNetDefaultTypeInternal _EquipBagNotifyNet_default_instance_;
class EquipBaseInfo;
class EquipBaseInfoDefaultTypeInternal;
extern EquipBaseInfoDefaultTypeInternal _EquipBaseInfo_default_instance_;
class EquipChangeInfo;
class EquipChangeInfoDefaultTypeInternal;
extern EquipChangeInfoDefaultTypeInternal _EquipChangeInfo_default_instance_;
class EquipChangeNotifyNet;
class EquipChangeNotifyNetDefaultTypeInternal;
extern EquipChangeNotifyNetDefaultTypeInternal _EquipChangeNotifyNet_default_instance_;
class EquipInfo;
class EquipInfoDefaultTypeInternal;
extern EquipInfoDefaultTypeInternal _EquipInfo_default_instance_;
class ErrorNotifyNet;
class ErrorNotifyNetDefaultTypeInternal;
extern ErrorNotifyNetDefaultTypeInternal _ErrorNotifyNet_default_instance_;
class GMCMDReqNet;
class GMCMDReqNetDefaultTypeInternal;
extern GMCMDReqNetDefaultTypeInternal _GMCMDReqNet_default_instance_;
class GMCMDRspNet;
class GMCMDRspNetDefaultTypeInternal;
extern GMCMDRspNetDefaultTypeInternal _GMCMDRspNet_default_instance_;
class ItemBag;
class ItemBagDefaultTypeInternal;
extern ItemBagDefaultTypeInternal _ItemBag_default_instance_;
class ItemBaseInfo;
class ItemBaseInfoDefaultTypeInternal;
extern ItemBaseInfoDefaultTypeInternal _ItemBaseInfo_default_instance_;
class ItemChangeInfo;
class ItemChangeInfoDefaultTypeInternal;
extern ItemChangeInfoDefaultTypeInternal _ItemChangeInfo_default_instance_;
class ItemChangeNotifyNet;
class ItemChangeNotifyNetDefaultTypeInternal;
extern ItemChangeNotifyNetDefaultTypeInternal _ItemChangeNotifyNet_default_instance_;
class ItemInfo;
class ItemInfoDefaultTypeInternal;
extern ItemInfoDefaultTypeInternal _ItemInfo_default_instance_;
class LoginGameReqNet;
class LoginGameReqNetDefaultTypeInternal;
extern LoginGameReqNetDefaultTypeInternal _LoginGameReqNet_default_instance_;
class LoginGameRspNet;
class LoginGameRspNetDefaultTypeInternal;
extern LoginGameRspNetDefaultTypeInternal _LoginGameRspNet_default_instance_;
class LoginReqNet;
class LoginReqNetDefaultTypeInternal;
extern LoginReqNetDefaultTypeInternal _LoginReqNet_default_instance_;
class LoginRspNet;
class LoginRspNetDefaultTypeInternal;
extern LoginRspNetDefaultTypeInternal _LoginRspNet_default_instance_;
class MapPos;
class MapPosDefaultTypeInternal;
extern MapPosDefaultTypeInternal _MapPos_default_instance_;
class PlayerBaseInfo;
class PlayerBaseInfoDefaultTypeInternal;
extern PlayerBaseInfoDefaultTypeInternal _PlayerBaseInfo_default_instance_;
class RoleBaseInfo;
class RoleBaseInfoDefaultTypeInternal;
extern RoleBaseInfoDefaultTypeInternal _RoleBaseInfo_default_instance_;
class RoleInfo;
class RoleInfoDefaultTypeInternal;
extern RoleInfoDefaultTypeInternal _RoleInfo_default_instance_;
class SelectGameServerReqNet;
class SelectGameServerReqNetDefaultTypeInternal;
extern SelectGameServerReqNetDefaultTypeInternal _SelectGameServerReqNet_default_instance_;
class SelectGameServerRspNet;
class SelectGameServerRspNetDefaultTypeInternal;
extern SelectGameServerRspNetDefaultTypeInternal _SelectGameServerRspNet_default_instance_;
class ServerInfo;
class ServerInfoDefaultTypeInternal;
extern ServerInfoDefaultTypeInternal _ServerInfo_default_instance_;
class StringNet;
class StringNetDefaultTypeInternal;
extern StringNetDefaultTypeInternal _StringNet_default_instance_;
class Uint32ListNet;
class Uint32ListNetDefaultTypeInternal;
extern Uint32ListNetDefaultTypeInternal _Uint32ListNet_default_instance_;
class Uint32Net;
class Uint32NetDefaultTypeInternal;
extern Uint32NetDefaultTypeInternal _Uint32Net_default_instance_;
class Uint64Net;
class Uint64NetDefaultTypeInternal;
extern Uint64NetDefaultTypeInternal _Uint64Net_default_instance_;
class UpdLoginReqNet;
class UpdLoginReqNetDefaultTypeInternal;
extern UpdLoginReqNetDefaultTypeInternal _UpdLoginReqNet_default_instance_;
class UpdLoginRspNet;
class UpdLoginRspNetDefaultTypeInternal;
extern UpdLoginRspNetDefaultTypeInternal _UpdLoginRspNet_default_instance_;
class UpdTestReqNet;
class UpdTestReqNetDefaultTypeInternal;
extern UpdTestReqNetDefaultTypeInternal _UpdTestReqNet_default_instance_;
class UpdTestRspNet;
class UpdTestRspNetDefaultTypeInternal;
extern UpdTestRspNetDefaultTypeInternal _UpdTestRspNet_default_instance_;
}  // namespace protocol
namespace protocol {

enum NetMsgID {
  NetMsgID_none = 0,
  cs_heartBeat = 1001,
  sc_heartBeat = 1002,
  cs_login = 1003,
  sc_login = 1004,
  cs_selectGameServer = 1005,
  sc_selectGameServer = 1006,
  cs_loginGame = 1007,
  sc_loginGame = 1008,
  cs_createRole = 1009,
  sc_createRole = 1010,
  cs_enterScene = 1011,
  sc_enterScene = 1012,
  sc_errorNotify = 1018,
  cs_udpLogin = 1019,
  sc_udpLogin = 1020,
  cs_udpTest = 1021,
  sc_udpTest = 1022,
  cs_buyRoleSolt = 1023,
  sc_buyRoleSolt = 1024,
  cs_itemBagNotify = 2003,
  sc_itemBagNotify = 2004,
  cs_equipBagNotify = 2005,
  sc_equipBagNotify = 2006,
  sc_itemChangeNotify = 2008,
  sc_equipChangeNotify = 2010,
  cs_buyBagSolt = 2011,
  sc_buyBagSolt = 2012,
  cs_GMCMD = 3001,
  sc_GMCMD = 3002
};
bool NetMsgID_IsValid(int value);
const NetMsgID NetMsgID_MIN = NetMsgID_none;
const NetMsgID NetMsgID_MAX = sc_GMCMD;
const int NetMsgID_ARRAYSIZE = NetMsgID_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetMsgID_descriptor();
inline const ::std::string& NetMsgID_Name(NetMsgID value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetMsgID_descriptor(), value);
}
inline bool NetMsgID_Parse(
    const ::std::string& name, NetMsgID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetMsgID>(
    NetMsgID_descriptor(), name, value);
}
// ===================================================================

class StringNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.StringNet) */ {
 public:
  StringNet();
  virtual ~StringNet();

  StringNet(const StringNet& from);

  inline StringNet& operator=(const StringNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringNet(StringNet&& from) noexcept
    : StringNet() {
    *this = ::std::move(from);
  }

  inline StringNet& operator=(StringNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringNet* internal_default_instance() {
    return reinterpret_cast<const StringNet*>(
               &_StringNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(StringNet* other);
  friend void swap(StringNet& a, StringNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringNet* New() const PROTOBUF_FINAL { return New(NULL); }

  StringNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StringNet& from);
  void MergeFrom(const StringNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StringNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:protocol.StringNet)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsStringNetImpl();
};
// -------------------------------------------------------------------

class Uint32Net : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Uint32Net) */ {
 public:
  Uint32Net();
  virtual ~Uint32Net();

  Uint32Net(const Uint32Net& from);

  inline Uint32Net& operator=(const Uint32Net& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uint32Net(Uint32Net&& from) noexcept
    : Uint32Net() {
    *this = ::std::move(from);
  }

  inline Uint32Net& operator=(Uint32Net&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uint32Net& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint32Net* internal_default_instance() {
    return reinterpret_cast<const Uint32Net*>(
               &_Uint32Net_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Uint32Net* other);
  friend void swap(Uint32Net& a, Uint32Net& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uint32Net* New() const PROTOBUF_FINAL { return New(NULL); }

  Uint32Net* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Uint32Net& from);
  void MergeFrom(const Uint32Net& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Uint32Net* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Uint32Net)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUint32NetImpl();
};
// -------------------------------------------------------------------

class Uint32ListNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Uint32ListNet) */ {
 public:
  Uint32ListNet();
  virtual ~Uint32ListNet();

  Uint32ListNet(const Uint32ListNet& from);

  inline Uint32ListNet& operator=(const Uint32ListNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uint32ListNet(Uint32ListNet&& from) noexcept
    : Uint32ListNet() {
    *this = ::std::move(from);
  }

  inline Uint32ListNet& operator=(Uint32ListNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uint32ListNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint32ListNet* internal_default_instance() {
    return reinterpret_cast<const Uint32ListNet*>(
               &_Uint32ListNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Uint32ListNet* other);
  friend void swap(Uint32ListNet& a, Uint32ListNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uint32ListNet* New() const PROTOBUF_FINAL { return New(NULL); }

  Uint32ListNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Uint32ListNet& from);
  void MergeFrom(const Uint32ListNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Uint32ListNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 valueList = 1;
  int valuelist_size() const;
  void clear_valuelist();
  static const int kValueListFieldNumber = 1;
  ::google::protobuf::uint32 valuelist(int index) const;
  void set_valuelist(int index, ::google::protobuf::uint32 value);
  void add_valuelist(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      valuelist() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_valuelist();

  // @@protoc_insertion_point(class_scope:protocol.Uint32ListNet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > valuelist_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUint32ListNetImpl();
};
// -------------------------------------------------------------------

class Uint64Net : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.Uint64Net) */ {
 public:
  Uint64Net();
  virtual ~Uint64Net();

  Uint64Net(const Uint64Net& from);

  inline Uint64Net& operator=(const Uint64Net& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Uint64Net(Uint64Net&& from) noexcept
    : Uint64Net() {
    *this = ::std::move(from);
  }

  inline Uint64Net& operator=(Uint64Net&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uint64Net& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Uint64Net* internal_default_instance() {
    return reinterpret_cast<const Uint64Net*>(
               &_Uint64Net_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Uint64Net* other);
  friend void swap(Uint64Net& a, Uint64Net& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Uint64Net* New() const PROTOBUF_FINAL { return New(NULL); }

  Uint64Net* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Uint64Net& from);
  void MergeFrom(const Uint64Net& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Uint64Net* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.Uint64Net)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 value_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUint64NetImpl();
};
// -------------------------------------------------------------------

class DoubleInt32Net : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DoubleInt32Net) */ {
 public:
  DoubleInt32Net();
  virtual ~DoubleInt32Net();

  DoubleInt32Net(const DoubleInt32Net& from);

  inline DoubleInt32Net& operator=(const DoubleInt32Net& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleInt32Net(DoubleInt32Net&& from) noexcept
    : DoubleInt32Net() {
    *this = ::std::move(from);
  }

  inline DoubleInt32Net& operator=(DoubleInt32Net&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleInt32Net& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleInt32Net* internal_default_instance() {
    return reinterpret_cast<const DoubleInt32Net*>(
               &_DoubleInt32Net_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(DoubleInt32Net* other);
  friend void swap(DoubleInt32Net& a, DoubleInt32Net& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleInt32Net* New() const PROTOBUF_FINAL { return New(NULL); }

  DoubleInt32Net* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DoubleInt32Net& from);
  void MergeFrom(const DoubleInt32Net& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DoubleInt32Net* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::int32 key() const;
  void set_key(::google::protobuf::int32 value);

  // required int32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.DoubleInt32Net)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 key_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsDoubleInt32NetImpl();
};
// -------------------------------------------------------------------

class DoubleUint64Net : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.DoubleUint64Net) */ {
 public:
  DoubleUint64Net();
  virtual ~DoubleUint64Net();

  DoubleUint64Net(const DoubleUint64Net& from);

  inline DoubleUint64Net& operator=(const DoubleUint64Net& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleUint64Net(DoubleUint64Net&& from) noexcept
    : DoubleUint64Net() {
    *this = ::std::move(from);
  }

  inline DoubleUint64Net& operator=(DoubleUint64Net&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleUint64Net& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleUint64Net* internal_default_instance() {
    return reinterpret_cast<const DoubleUint64Net*>(
               &_DoubleUint64Net_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(DoubleUint64Net* other);
  friend void swap(DoubleUint64Net& a, DoubleUint64Net& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleUint64Net* New() const PROTOBUF_FINAL { return New(NULL); }

  DoubleUint64Net* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DoubleUint64Net& from);
  void MergeFrom(const DoubleUint64Net& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DoubleUint64Net* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint64 key() const;
  void set_key(::google::protobuf::uint64 value);

  // required uint64 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:protocol.DoubleUint64Net)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint64 key_;
  ::google::protobuf::uint64 value_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsDoubleUint64NetImpl();
};
// -------------------------------------------------------------------

class ServerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ServerInfo) */ {
 public:
  ServerInfo();
  virtual ~ServerInfo();

  ServerInfo(const ServerInfo& from);

  inline ServerInfo& operator=(const ServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerInfo(ServerInfo&& from) noexcept
    : ServerInfo() {
    *this = ::std::move(from);
  }

  inline ServerInfo& operator=(ServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerInfo* internal_default_instance() {
    return reinterpret_cast<const ServerInfo*>(
               &_ServerInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ServerInfo* other);
  friend void swap(ServerInfo& a, ServerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerInfo& from);
  void MergeFrom(const ServerInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string serverIp = 1;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServerIpFieldNumber = 1;
  const ::std::string& serverip() const;
  void set_serverip(const ::std::string& value);
  #if LANG_CXX11
  void set_serverip(::std::string&& value);
  #endif
  void set_serverip(const char* value);
  void set_serverip(const char* value, size_t size);
  ::std::string* mutable_serverip();
  ::std::string* release_serverip();
  void set_allocated_serverip(::std::string* serverip);

  // required int32 serverPort = 2;
  bool has_serverport() const;
  void clear_serverport();
  static const int kServerPortFieldNumber = 2;
  ::google::protobuf::int32 serverport() const;
  void set_serverport(::google::protobuf::int32 value);

  // optional int32 serverId = 3;
  bool has_serverid() const;
  void clear_serverid();
  static const int kServerIdFieldNumber = 3;
  ::google::protobuf::int32 serverid() const;
  void set_serverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ServerInfo)
 private:
  void set_has_serverip();
  void clear_has_serverip();
  void set_has_serverport();
  void clear_has_serverport();
  void set_has_serverid();
  void clear_has_serverid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serverip_;
  ::google::protobuf::int32 serverport_;
  ::google::protobuf::int32 serverid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsServerInfoImpl();
};
// -------------------------------------------------------------------

class MapPos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.MapPos) */ {
 public:
  MapPos();
  virtual ~MapPos();

  MapPos(const MapPos& from);

  inline MapPos& operator=(const MapPos& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapPos(MapPos&& from) noexcept
    : MapPos() {
    *this = ::std::move(from);
  }

  inline MapPos& operator=(MapPos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapPos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapPos* internal_default_instance() {
    return reinterpret_cast<const MapPos*>(
               &_MapPos_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(MapPos* other);
  friend void swap(MapPos& a, MapPos& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapPos* New() const PROTOBUF_FINAL { return New(NULL); }

  MapPos* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MapPos& from);
  void MergeFrom(const MapPos& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MapPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int64 x() const;
  void set_x(::google::protobuf::int64 value);

  // required int64 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int64 y() const;
  void set_y(::google::protobuf::int64 value);

  // required int64 z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  ::google::protobuf::int64 z() const;
  void set_z(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.MapPos)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 x_;
  ::google::protobuf::int64 y_;
  ::google::protobuf::int64 z_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsMapPosImpl();
};
// -------------------------------------------------------------------

class PlayerBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.PlayerBaseInfo) */ {
 public:
  PlayerBaseInfo();
  virtual ~PlayerBaseInfo();

  PlayerBaseInfo(const PlayerBaseInfo& from);

  inline PlayerBaseInfo& operator=(const PlayerBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerBaseInfo(PlayerBaseInfo&& from) noexcept
    : PlayerBaseInfo() {
    *this = ::std::move(from);
  }

  inline PlayerBaseInfo& operator=(PlayerBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerBaseInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerBaseInfo*>(
               &_PlayerBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PlayerBaseInfo* other);
  friend void swap(PlayerBaseInfo& a, PlayerBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PlayerBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerBaseInfo& from);
  void MergeFrom(const PlayerBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 playerId = 1;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  ::google::protobuf::int64 playerid() const;
  void set_playerid(::google::protobuf::int64 value);

  // required int32 diamond = 2;
  bool has_diamond() const;
  void clear_diamond();
  static const int kDiamondFieldNumber = 2;
  ::google::protobuf::int32 diamond() const;
  void set_diamond(::google::protobuf::int32 value);

  // required int32 vipLevel = 3;
  bool has_viplevel() const;
  void clear_viplevel();
  static const int kVipLevelFieldNumber = 3;
  ::google::protobuf::int32 viplevel() const;
  void set_viplevel(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.PlayerBaseInfo)
 private:
  void set_has_playerid();
  void clear_has_playerid();
  void set_has_diamond();
  void clear_has_diamond();
  void set_has_viplevel();
  void clear_has_viplevel();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int32 diamond_;
  ::google::protobuf::int32 viplevel_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsPlayerBaseInfoImpl();
};
// -------------------------------------------------------------------

class RoleBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.RoleBaseInfo) */ {
 public:
  RoleBaseInfo();
  virtual ~RoleBaseInfo();

  RoleBaseInfo(const RoleBaseInfo& from);

  inline RoleBaseInfo& operator=(const RoleBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoleBaseInfo(RoleBaseInfo&& from) noexcept
    : RoleBaseInfo() {
    *this = ::std::move(from);
  }

  inline RoleBaseInfo& operator=(RoleBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoleBaseInfo* internal_default_instance() {
    return reinterpret_cast<const RoleBaseInfo*>(
               &_RoleBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(RoleBaseInfo* other);
  friend void swap(RoleBaseInfo& a, RoleBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoleBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoleBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoleBaseInfo& from);
  void MergeFrom(const RoleBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoleBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 4;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .protocol.EquipInfo equips = 6;
  bool has_equips() const;
  void clear_equips();
  static const int kEquipsFieldNumber = 6;
  const ::protocol::EquipInfo& equips() const;
  ::protocol::EquipInfo* release_equips();
  ::protocol::EquipInfo* mutable_equips();
  void set_allocated_equips(::protocol::EquipInfo* equips);

  // required int64 roleId = 1;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  ::google::protobuf::int64 roleid() const;
  void set_roleid(::google::protobuf::int64 value);

  // required int32 jobId = 2;
  bool has_jobid() const;
  void clear_jobid();
  static const int kJobIdFieldNumber = 2;
  ::google::protobuf::int32 jobid() const;
  void set_jobid(::google::protobuf::int32 value);

  // required int32 sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // required int32 level = 5;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 5;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 mainCityId = 7;
  bool has_maincityid() const;
  void clear_maincityid();
  static const int kMainCityIdFieldNumber = 7;
  ::google::protobuf::int32 maincityid() const;
  void set_maincityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.RoleBaseInfo)
 private:
  void set_has_roleid();
  void clear_has_roleid();
  void set_has_jobid();
  void clear_has_jobid();
  void set_has_sex();
  void clear_has_sex();
  void set_has_name();
  void clear_has_name();
  void set_has_level();
  void clear_has_level();
  void set_has_equips();
  void clear_has_equips();
  void set_has_maincityid();
  void clear_has_maincityid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::protocol::EquipInfo* equips_;
  ::google::protobuf::int64 roleid_;
  ::google::protobuf::int32 jobid_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 maincityid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsRoleBaseInfoImpl();
};
// -------------------------------------------------------------------

class ItemBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ItemBaseInfo) */ {
 public:
  ItemBaseInfo();
  virtual ~ItemBaseInfo();

  ItemBaseInfo(const ItemBaseInfo& from);

  inline ItemBaseInfo& operator=(const ItemBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemBaseInfo(ItemBaseInfo&& from) noexcept
    : ItemBaseInfo() {
    *this = ::std::move(from);
  }

  inline ItemBaseInfo& operator=(ItemBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemBaseInfo* internal_default_instance() {
    return reinterpret_cast<const ItemBaseInfo*>(
               &_ItemBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ItemBaseInfo* other);
  friend void swap(ItemBaseInfo& a, ItemBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemBaseInfo& from);
  void MergeFrom(const ItemBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // required int64 count = 3;
  bool has_count() const;
  void clear_count();
  static const int kCountFieldNumber = 3;
  ::google::protobuf::int64 count() const;
  void set_count(::google::protobuf::int64 value);

  // required int64 uid = 4;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 4;
  ::google::protobuf::int64 uid() const;
  void set_uid(::google::protobuf::int64 value);

  // required int32 itemType = 1;
  bool has_itemtype() const;
  void clear_itemtype();
  static const int kItemTypeFieldNumber = 1;
  ::google::protobuf::int32 itemtype() const;
  void set_itemtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ItemBaseInfo)
 private:
  void set_has_itemtype();
  void clear_has_itemtype();
  void set_has_id();
  void clear_has_id();
  void set_has_count();
  void clear_has_count();
  void set_has_uid();
  void clear_has_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 count_;
  ::google::protobuf::int64 uid_;
  ::google::protobuf::int32 itemtype_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsItemBaseInfoImpl();
};
// -------------------------------------------------------------------

class ItemInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ItemInfo) */ {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemInfo(ItemInfo&& from) noexcept
    : ItemInfo() {
    *this = ::std::move(from);
  }

  inline ItemInfo& operator=(ItemInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemInfo* internal_default_instance() {
    return reinterpret_cast<const ItemInfo*>(
               &_ItemInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(ItemInfo* other);
  friend void swap(ItemInfo& a, ItemInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.ItemBaseInfo baseInfo = 1;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  const ::protocol::ItemBaseInfo& baseinfo() const;
  ::protocol::ItemBaseInfo* release_baseinfo();
  ::protocol::ItemBaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::protocol::ItemBaseInfo* baseinfo);

  // @@protoc_insertion_point(class_scope:protocol.ItemInfo)
 private:
  void set_has_baseinfo();
  void clear_has_baseinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::ItemBaseInfo* baseinfo_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsItemInfoImpl();
};
// -------------------------------------------------------------------

class ItemChangeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ItemChangeInfo) */ {
 public:
  ItemChangeInfo();
  virtual ~ItemChangeInfo();

  ItemChangeInfo(const ItemChangeInfo& from);

  inline ItemChangeInfo& operator=(const ItemChangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemChangeInfo(ItemChangeInfo&& from) noexcept
    : ItemChangeInfo() {
    *this = ::std::move(from);
  }

  inline ItemChangeInfo& operator=(ItemChangeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemChangeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemChangeInfo* internal_default_instance() {
    return reinterpret_cast<const ItemChangeInfo*>(
               &_ItemChangeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ItemChangeInfo* other);
  friend void swap(ItemChangeInfo& a, ItemChangeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemChangeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemChangeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemChangeInfo& from);
  void MergeFrom(const ItemChangeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemChangeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.ItemInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::protocol::ItemInfo& info() const;
  ::protocol::ItemInfo* release_info();
  ::protocol::ItemInfo* mutable_info();
  void set_allocated_info(::protocol::ItemInfo* info);

  // required int32 change = 2;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 2;
  ::google::protobuf::int32 change() const;
  void set_change(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ItemChangeInfo)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_change();
  void clear_has_change();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::ItemInfo* info_;
  ::google::protobuf::int32 change_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsItemChangeInfoImpl();
};
// -------------------------------------------------------------------

class ItemBag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ItemBag) */ {
 public:
  ItemBag();
  virtual ~ItemBag();

  ItemBag(const ItemBag& from);

  inline ItemBag& operator=(const ItemBag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemBag(ItemBag&& from) noexcept
    : ItemBag() {
    *this = ::std::move(from);
  }

  inline ItemBag& operator=(ItemBag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemBag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemBag* internal_default_instance() {
    return reinterpret_cast<const ItemBag*>(
               &_ItemBag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(ItemBag* other);
  friend void swap(ItemBag& a, ItemBag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemBag* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemBag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemBag& from);
  void MergeFrom(const ItemBag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemBag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.ItemInfo infos = 1;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 1;
  const ::protocol::ItemInfo& infos(int index) const;
  ::protocol::ItemInfo* mutable_infos(int index);
  ::protocol::ItemInfo* add_infos();
  ::google::protobuf::RepeatedPtrField< ::protocol::ItemInfo >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::protocol::ItemInfo >&
      infos() const;

  // required int32 consumptionsBag = 2;
  bool has_consumptionsbag() const;
  void clear_consumptionsbag();
  static const int kConsumptionsBagFieldNumber = 2;
  ::google::protobuf::int32 consumptionsbag() const;
  void set_consumptionsbag(::google::protobuf::int32 value);

  // required int32 materialsBag = 3;
  bool has_materialsbag() const;
  void clear_materialsbag();
  static const int kMaterialsBagFieldNumber = 3;
  ::google::protobuf::int32 materialsbag() const;
  void set_materialsbag(::google::protobuf::int32 value);

  // required int32 questsBag = 4;
  bool has_questsbag() const;
  void clear_questsbag();
  static const int kQuestsBagFieldNumber = 4;
  ::google::protobuf::int32 questsbag() const;
  void set_questsbag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ItemBag)
 private:
  void set_has_consumptionsbag();
  void clear_has_consumptionsbag();
  void set_has_materialsbag();
  void clear_has_materialsbag();
  void set_has_questsbag();
  void clear_has_questsbag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ItemInfo > infos_;
  ::google::protobuf::int32 consumptionsbag_;
  ::google::protobuf::int32 materialsbag_;
  ::google::protobuf::int32 questsbag_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsItemBagImpl();
};
// -------------------------------------------------------------------

class EquipBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipBaseInfo) */ {
 public:
  EquipBaseInfo();
  virtual ~EquipBaseInfo();

  EquipBaseInfo(const EquipBaseInfo& from);

  inline EquipBaseInfo& operator=(const EquipBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipBaseInfo(EquipBaseInfo&& from) noexcept
    : EquipBaseInfo() {
    *this = ::std::move(from);
  }

  inline EquipBaseInfo& operator=(EquipBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipBaseInfo* internal_default_instance() {
    return reinterpret_cast<const EquipBaseInfo*>(
               &_EquipBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(EquipBaseInfo* other);
  friend void swap(EquipBaseInfo& a, EquipBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipBaseInfo& from);
  void MergeFrom(const EquipBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // required int64 uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  ::google::protobuf::int64 uid() const;
  void set_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.EquipBaseInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_uid();
  void clear_has_uid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 id_;
  ::google::protobuf::int64 uid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipBaseInfoImpl();
};
// -------------------------------------------------------------------

class EquipInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipInfo) */ {
 public:
  EquipInfo();
  virtual ~EquipInfo();

  EquipInfo(const EquipInfo& from);

  inline EquipInfo& operator=(const EquipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipInfo(EquipInfo&& from) noexcept
    : EquipInfo() {
    *this = ::std::move(from);
  }

  inline EquipInfo& operator=(EquipInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipInfo* internal_default_instance() {
    return reinterpret_cast<const EquipInfo*>(
               &_EquipInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(EquipInfo* other);
  friend void swap(EquipInfo& a, EquipInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipInfo& from);
  void MergeFrom(const EquipInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.EquipBaseInfo baseInfo = 1;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  const ::protocol::EquipBaseInfo& baseinfo() const;
  ::protocol::EquipBaseInfo* release_baseinfo();
  ::protocol::EquipBaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::protocol::EquipBaseInfo* baseinfo);

  // @@protoc_insertion_point(class_scope:protocol.EquipInfo)
 private:
  void set_has_baseinfo();
  void clear_has_baseinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::EquipBaseInfo* baseinfo_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipInfoImpl();
};
// -------------------------------------------------------------------

class EquipChangeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipChangeInfo) */ {
 public:
  EquipChangeInfo();
  virtual ~EquipChangeInfo();

  EquipChangeInfo(const EquipChangeInfo& from);

  inline EquipChangeInfo& operator=(const EquipChangeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipChangeInfo(EquipChangeInfo&& from) noexcept
    : EquipChangeInfo() {
    *this = ::std::move(from);
  }

  inline EquipChangeInfo& operator=(EquipChangeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipChangeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipChangeInfo* internal_default_instance() {
    return reinterpret_cast<const EquipChangeInfo*>(
               &_EquipChangeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(EquipChangeInfo* other);
  friend void swap(EquipChangeInfo& a, EquipChangeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipChangeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipChangeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipChangeInfo& from);
  void MergeFrom(const EquipChangeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipChangeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.EquipInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::protocol::EquipInfo& info() const;
  ::protocol::EquipInfo* release_info();
  ::protocol::EquipInfo* mutable_info();
  void set_allocated_info(::protocol::EquipInfo* info);

  // required int32 change = 2;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 2;
  ::google::protobuf::int32 change() const;
  void set_change(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.EquipChangeInfo)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_change();
  void clear_has_change();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::EquipInfo* info_;
  ::google::protobuf::int32 change_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipChangeInfoImpl();
};
// -------------------------------------------------------------------

class EquipBag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipBag) */ {
 public:
  EquipBag();
  virtual ~EquipBag();

  EquipBag(const EquipBag& from);

  inline EquipBag& operator=(const EquipBag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipBag(EquipBag&& from) noexcept
    : EquipBag() {
    *this = ::std::move(from);
  }

  inline EquipBag& operator=(EquipBag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipBag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipBag* internal_default_instance() {
    return reinterpret_cast<const EquipBag*>(
               &_EquipBag_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(EquipBag* other);
  friend void swap(EquipBag& a, EquipBag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipBag* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipBag* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipBag& from);
  void MergeFrom(const EquipBag& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipBag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.EquipInfo infos = 1;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 1;
  const ::protocol::EquipInfo& infos(int index) const;
  ::protocol::EquipInfo* mutable_infos(int index);
  ::protocol::EquipInfo* add_infos();
  ::google::protobuf::RepeatedPtrField< ::protocol::EquipInfo >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::protocol::EquipInfo >&
      infos() const;

  // required int32 bag = 2;
  bool has_bag() const;
  void clear_bag();
  static const int kBagFieldNumber = 2;
  ::google::protobuf::int32 bag() const;
  void set_bag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.EquipBag)
 private:
  void set_has_bag();
  void clear_has_bag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::EquipInfo > infos_;
  ::google::protobuf::int32 bag_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipBagImpl();
};
// -------------------------------------------------------------------

class RoleInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.RoleInfo) */ {
 public:
  RoleInfo();
  virtual ~RoleInfo();

  RoleInfo(const RoleInfo& from);

  inline RoleInfo& operator=(const RoleInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoleInfo(RoleInfo&& from) noexcept
    : RoleInfo() {
    *this = ::std::move(from);
  }

  inline RoleInfo& operator=(RoleInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoleInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoleInfo* internal_default_instance() {
    return reinterpret_cast<const RoleInfo*>(
               &_RoleInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(RoleInfo* other);
  friend void swap(RoleInfo& a, RoleInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoleInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoleInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoleInfo& from);
  void MergeFrom(const RoleInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.RoleBaseInfo baseInfo = 1;
  bool has_baseinfo() const;
  void clear_baseinfo();
  static const int kBaseInfoFieldNumber = 1;
  const ::protocol::RoleBaseInfo& baseinfo() const;
  ::protocol::RoleBaseInfo* release_baseinfo();
  ::protocol::RoleBaseInfo* mutable_baseinfo();
  void set_allocated_baseinfo(::protocol::RoleBaseInfo* baseinfo);

  // required .protocol.MapPos pos = 5;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 5;
  const ::protocol::MapPos& pos() const;
  ::protocol::MapPos* release_pos();
  ::protocol::MapPos* mutable_pos();
  void set_allocated_pos(::protocol::MapPos* pos);

  // required int64 money = 2;
  bool has_money() const;
  void clear_money();
  static const int kMoneyFieldNumber = 2;
  ::google::protobuf::int64 money() const;
  void set_money(::google::protobuf::int64 value);

  // required int64 exp = 3;
  bool has_exp() const;
  void clear_exp();
  static const int kExpFieldNumber = 3;
  ::google::protobuf::int64 exp() const;
  void set_exp(::google::protobuf::int64 value);

  // optional int32 skillPoint = 6;
  bool has_skillpoint() const;
  void clear_skillpoint();
  static const int kSkillPointFieldNumber = 6;
  ::google::protobuf::int32 skillpoint() const;
  void set_skillpoint(::google::protobuf::int32 value);

  // optional int32 energy = 7;
  bool has_energy() const;
  void clear_energy();
  static const int kEnergyFieldNumber = 7;
  ::google::protobuf::int32 energy() const;
  void set_energy(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.RoleInfo)
 private:
  void set_has_baseinfo();
  void clear_has_baseinfo();
  void set_has_money();
  void clear_has_money();
  void set_has_exp();
  void clear_has_exp();
  void set_has_pos();
  void clear_has_pos();
  void set_has_skillpoint();
  void clear_has_skillpoint();
  void set_has_energy();
  void clear_has_energy();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::RoleBaseInfo* baseinfo_;
  ::protocol::MapPos* pos_;
  ::google::protobuf::int64 money_;
  ::google::protobuf::int64 exp_;
  ::google::protobuf::int32 skillpoint_;
  ::google::protobuf::int32 energy_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsRoleInfoImpl();
};
// -------------------------------------------------------------------

class LoginReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LoginReqNet) */ {
 public:
  LoginReqNet();
  virtual ~LoginReqNet();

  LoginReqNet(const LoginReqNet& from);

  inline LoginReqNet& operator=(const LoginReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginReqNet(LoginReqNet&& from) noexcept
    : LoginReqNet() {
    *this = ::std::move(from);
  }

  inline LoginReqNet& operator=(LoginReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginReqNet* internal_default_instance() {
    return reinterpret_cast<const LoginReqNet*>(
               &_LoginReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(LoginReqNet* other);
  friend void swap(LoginReqNet& a, LoginReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginReqNet& from);
  void MergeFrom(const LoginReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string channelId = 1;
  bool has_channelid() const;
  void clear_channelid();
  static const int kChannelIdFieldNumber = 1;
  const ::std::string& channelid() const;
  void set_channelid(const ::std::string& value);
  #if LANG_CXX11
  void set_channelid(::std::string&& value);
  #endif
  void set_channelid(const char* value);
  void set_channelid(const char* value, size_t size);
  ::std::string* mutable_channelid();
  ::std::string* release_channelid();
  void set_allocated_channelid(::std::string* channelid);

  // required string uid = 2;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 2;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // optional string sdkToken = 3;
  bool has_sdktoken() const;
  void clear_sdktoken();
  static const int kSdkTokenFieldNumber = 3;
  const ::std::string& sdktoken() const;
  void set_sdktoken(const ::std::string& value);
  #if LANG_CXX11
  void set_sdktoken(::std::string&& value);
  #endif
  void set_sdktoken(const char* value);
  void set_sdktoken(const char* value, size_t size);
  ::std::string* mutable_sdktoken();
  ::std::string* release_sdktoken();
  void set_allocated_sdktoken(::std::string* sdktoken);

  // optional string sdkSession = 4;
  bool has_sdksession() const;
  void clear_sdksession();
  static const int kSdkSessionFieldNumber = 4;
  const ::std::string& sdksession() const;
  void set_sdksession(const ::std::string& value);
  #if LANG_CXX11
  void set_sdksession(::std::string&& value);
  #endif
  void set_sdksession(const char* value);
  void set_sdksession(const char* value, size_t size);
  ::std::string* mutable_sdksession();
  ::std::string* release_sdksession();
  void set_allocated_sdksession(::std::string* sdksession);

  // optional string deviceId = 8;
  bool has_deviceid() const;
  void clear_deviceid();
  static const int kDeviceIdFieldNumber = 8;
  const ::std::string& deviceid() const;
  void set_deviceid(const ::std::string& value);
  #if LANG_CXX11
  void set_deviceid(::std::string&& value);
  #endif
  void set_deviceid(const char* value);
  void set_deviceid(const char* value, size_t size);
  ::std::string* mutable_deviceid();
  ::std::string* release_deviceid();
  void set_allocated_deviceid(::std::string* deviceid);

  // required int32 loginType = 5;
  bool has_logintype() const;
  void clear_logintype();
  static const int kLoginTypeFieldNumber = 5;
  ::google::protobuf::int32 logintype() const;
  void set_logintype(::google::protobuf::int32 value);

  // optional int32 version = 6;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 6;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // optional int32 runtime = 7;
  bool has_runtime() const;
  void clear_runtime();
  static const int kRuntimeFieldNumber = 7;
  ::google::protobuf::int32 runtime() const;
  void set_runtime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.LoginReqNet)
 private:
  void set_has_channelid();
  void clear_has_channelid();
  void set_has_uid();
  void clear_has_uid();
  void set_has_sdktoken();
  void clear_has_sdktoken();
  void set_has_sdksession();
  void clear_has_sdksession();
  void set_has_logintype();
  void clear_has_logintype();
  void set_has_version();
  void clear_has_version();
  void set_has_runtime();
  void clear_has_runtime();
  void set_has_deviceid();
  void clear_has_deviceid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr channelid_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr sdktoken_;
  ::google::protobuf::internal::ArenaStringPtr sdksession_;
  ::google::protobuf::internal::ArenaStringPtr deviceid_;
  ::google::protobuf::int32 logintype_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 runtime_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsLoginReqNetImpl();
};
// -------------------------------------------------------------------

class LoginRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LoginRspNet) */ {
 public:
  LoginRspNet();
  virtual ~LoginRspNet();

  LoginRspNet(const LoginRspNet& from);

  inline LoginRspNet& operator=(const LoginRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRspNet(LoginRspNet&& from) noexcept
    : LoginRspNet() {
    *this = ::std::move(from);
  }

  inline LoginRspNet& operator=(LoginRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRspNet* internal_default_instance() {
    return reinterpret_cast<const LoginRspNet*>(
               &_LoginRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(LoginRspNet* other);
  friend void swap(LoginRspNet& a, LoginRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRspNet& from);
  void MergeFrom(const LoginRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // required int32 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.LoginRspNet)
 private:
  void set_has_account();
  void clear_has_account();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::int32 ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsLoginRspNetImpl();
};
// -------------------------------------------------------------------

class SelectGameServerReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.SelectGameServerReqNet) */ {
 public:
  SelectGameServerReqNet();
  virtual ~SelectGameServerReqNet();

  SelectGameServerReqNet(const SelectGameServerReqNet& from);

  inline SelectGameServerReqNet& operator=(const SelectGameServerReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectGameServerReqNet(SelectGameServerReqNet&& from) noexcept
    : SelectGameServerReqNet() {
    *this = ::std::move(from);
  }

  inline SelectGameServerReqNet& operator=(SelectGameServerReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectGameServerReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectGameServerReqNet* internal_default_instance() {
    return reinterpret_cast<const SelectGameServerReqNet*>(
               &_SelectGameServerReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(SelectGameServerReqNet* other);
  friend void swap(SelectGameServerReqNet& a, SelectGameServerReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectGameServerReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectGameServerReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectGameServerReqNet& from);
  void MergeFrom(const SelectGameServerReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectGameServerReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameServerId = 1;
  bool has_gameserverid() const;
  void clear_gameserverid();
  static const int kGameServerIdFieldNumber = 1;
  ::google::protobuf::int32 gameserverid() const;
  void set_gameserverid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.SelectGameServerReqNet)
 private:
  void set_has_gameserverid();
  void clear_has_gameserverid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 gameserverid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsSelectGameServerReqNetImpl();
};
// -------------------------------------------------------------------

class SelectGameServerRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.SelectGameServerRspNet) */ {
 public:
  SelectGameServerRspNet();
  virtual ~SelectGameServerRspNet();

  SelectGameServerRspNet(const SelectGameServerRspNet& from);

  inline SelectGameServerRspNet& operator=(const SelectGameServerRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectGameServerRspNet(SelectGameServerRspNet&& from) noexcept
    : SelectGameServerRspNet() {
    *this = ::std::move(from);
  }

  inline SelectGameServerRspNet& operator=(SelectGameServerRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectGameServerRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectGameServerRspNet* internal_default_instance() {
    return reinterpret_cast<const SelectGameServerRspNet*>(
               &_SelectGameServerRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(SelectGameServerRspNet* other);
  friend void swap(SelectGameServerRspNet& a, SelectGameServerRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectGameServerRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  SelectGameServerRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectGameServerRspNet& from);
  void MergeFrom(const SelectGameServerRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectGameServerRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gameToken = 3;
  bool has_gametoken() const;
  void clear_gametoken();
  static const int kGameTokenFieldNumber = 3;
  const ::std::string& gametoken() const;
  void set_gametoken(const ::std::string& value);
  #if LANG_CXX11
  void set_gametoken(::std::string&& value);
  #endif
  void set_gametoken(const char* value);
  void set_gametoken(const char* value, size_t size);
  ::std::string* mutable_gametoken();
  ::std::string* release_gametoken();
  void set_allocated_gametoken(::std::string* gametoken);

  // required .protocol.ServerInfo server = 1;
  bool has_server() const;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::protocol::ServerInfo& server() const;
  ::protocol::ServerInfo* release_server();
  ::protocol::ServerInfo* mutable_server();
  void set_allocated_server(::protocol::ServerInfo* server);

  // optional .protocol.ServerInfo udpserver = 2;
  bool has_udpserver() const;
  void clear_udpserver();
  static const int kUdpserverFieldNumber = 2;
  const ::protocol::ServerInfo& udpserver() const;
  ::protocol::ServerInfo* release_udpserver();
  ::protocol::ServerInfo* mutable_udpserver();
  void set_allocated_udpserver(::protocol::ServerInfo* udpserver);

  // required int32 ret = 4;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 4;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.SelectGameServerRspNet)
 private:
  void set_has_server();
  void clear_has_server();
  void set_has_udpserver();
  void clear_has_udpserver();
  void set_has_gametoken();
  void clear_has_gametoken();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gametoken_;
  ::protocol::ServerInfo* server_;
  ::protocol::ServerInfo* udpserver_;
  ::google::protobuf::int32 ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsSelectGameServerRspNetImpl();
};
// -------------------------------------------------------------------

class LoginGameReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LoginGameReqNet) */ {
 public:
  LoginGameReqNet();
  virtual ~LoginGameReqNet();

  LoginGameReqNet(const LoginGameReqNet& from);

  inline LoginGameReqNet& operator=(const LoginGameReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginGameReqNet(LoginGameReqNet&& from) noexcept
    : LoginGameReqNet() {
    *this = ::std::move(from);
  }

  inline LoginGameReqNet& operator=(LoginGameReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginGameReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginGameReqNet* internal_default_instance() {
    return reinterpret_cast<const LoginGameReqNet*>(
               &_LoginGameReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(LoginGameReqNet* other);
  friend void swap(LoginGameReqNet& a, LoginGameReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginGameReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginGameReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginGameReqNet& from);
  void MergeFrom(const LoginGameReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginGameReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string gameToken = 1;
  bool has_gametoken() const;
  void clear_gametoken();
  static const int kGameTokenFieldNumber = 1;
  const ::std::string& gametoken() const;
  void set_gametoken(const ::std::string& value);
  #if LANG_CXX11
  void set_gametoken(::std::string&& value);
  #endif
  void set_gametoken(const char* value);
  void set_gametoken(const char* value, size_t size);
  ::std::string* mutable_gametoken();
  ::std::string* release_gametoken();
  void set_allocated_gametoken(::std::string* gametoken);

  // required string account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:protocol.LoginGameReqNet)
 private:
  void set_has_gametoken();
  void clear_has_gametoken();
  void set_has_account();
  void clear_has_account();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr gametoken_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsLoginGameReqNetImpl();
};
// -------------------------------------------------------------------

class LoginGameRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.LoginGameRspNet) */ {
 public:
  LoginGameRspNet();
  virtual ~LoginGameRspNet();

  LoginGameRspNet(const LoginGameRspNet& from);

  inline LoginGameRspNet& operator=(const LoginGameRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginGameRspNet(LoginGameRspNet&& from) noexcept
    : LoginGameRspNet() {
    *this = ::std::move(from);
  }

  inline LoginGameRspNet& operator=(LoginGameRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginGameRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginGameRspNet* internal_default_instance() {
    return reinterpret_cast<const LoginGameRspNet*>(
               &_LoginGameRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(LoginGameRspNet* other);
  friend void swap(LoginGameRspNet& a, LoginGameRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginGameRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  LoginGameRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginGameRspNet& from);
  void MergeFrom(const LoginGameRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginGameRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.RoleBaseInfo roles = 3;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 3;
  const ::protocol::RoleBaseInfo& roles(int index) const;
  ::protocol::RoleBaseInfo* mutable_roles(int index);
  ::protocol::RoleBaseInfo* add_roles();
  ::google::protobuf::RepeatedPtrField< ::protocol::RoleBaseInfo >*
      mutable_roles();
  const ::google::protobuf::RepeatedPtrField< ::protocol::RoleBaseInfo >&
      roles() const;

  // optional .protocol.PlayerBaseInfo player = 2;
  bool has_player() const;
  void clear_player();
  static const int kPlayerFieldNumber = 2;
  const ::protocol::PlayerBaseInfo& player() const;
  ::protocol::PlayerBaseInfo* release_player();
  ::protocol::PlayerBaseInfo* mutable_player();
  void set_allocated_player(::protocol::PlayerBaseInfo* player);

  // required int32 ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // required int32 soltCount = 4;
  bool has_soltcount() const;
  void clear_soltcount();
  static const int kSoltCountFieldNumber = 4;
  ::google::protobuf::int32 soltcount() const;
  void set_soltcount(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.LoginGameRspNet)
 private:
  void set_has_ret();
  void clear_has_ret();
  void set_has_player();
  void clear_has_player();
  void set_has_soltcount();
  void clear_has_soltcount();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::RoleBaseInfo > roles_;
  ::protocol::PlayerBaseInfo* player_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 soltcount_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsLoginGameRspNetImpl();
};
// -------------------------------------------------------------------

class CreateRoleReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.CreateRoleReqNet) */ {
 public:
  CreateRoleReqNet();
  virtual ~CreateRoleReqNet();

  CreateRoleReqNet(const CreateRoleReqNet& from);

  inline CreateRoleReqNet& operator=(const CreateRoleReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoleReqNet(CreateRoleReqNet&& from) noexcept
    : CreateRoleReqNet() {
    *this = ::std::move(from);
  }

  inline CreateRoleReqNet& operator=(CreateRoleReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoleReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoleReqNet* internal_default_instance() {
    return reinterpret_cast<const CreateRoleReqNet*>(
               &_CreateRoleReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(CreateRoleReqNet* other);
  friend void swap(CreateRoleReqNet& a, CreateRoleReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoleReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoleReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoleReqNet& from);
  void MergeFrom(const CreateRoleReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoleReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int32 jobId = 2;
  bool has_jobid() const;
  void clear_jobid();
  static const int kJobIdFieldNumber = 2;
  ::google::protobuf::int32 jobid() const;
  void set_jobid(::google::protobuf::int32 value);

  // required int32 sex = 3;
  bool has_sex() const;
  void clear_sex();
  static const int kSexFieldNumber = 3;
  ::google::protobuf::int32 sex() const;
  void set_sex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateRoleReqNet)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_jobid();
  void clear_has_jobid();
  void set_has_sex();
  void clear_has_sex();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int32 jobid_;
  ::google::protobuf::int32 sex_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsCreateRoleReqNetImpl();
};
// -------------------------------------------------------------------

class CreateRoleRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.CreateRoleRspNet) */ {
 public:
  CreateRoleRspNet();
  virtual ~CreateRoleRspNet();

  CreateRoleRspNet(const CreateRoleRspNet& from);

  inline CreateRoleRspNet& operator=(const CreateRoleRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRoleRspNet(CreateRoleRspNet&& from) noexcept
    : CreateRoleRspNet() {
    *this = ::std::move(from);
  }

  inline CreateRoleRspNet& operator=(CreateRoleRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRoleRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRoleRspNet* internal_default_instance() {
    return reinterpret_cast<const CreateRoleRspNet*>(
               &_CreateRoleRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(CreateRoleRspNet* other);
  friend void swap(CreateRoleRspNet& a, CreateRoleRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRoleRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  CreateRoleRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreateRoleRspNet& from);
  void MergeFrom(const CreateRoleRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreateRoleRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.RoleBaseInfo role = 2;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 2;
  const ::protocol::RoleBaseInfo& role() const;
  ::protocol::RoleBaseInfo* release_role();
  ::protocol::RoleBaseInfo* mutable_role();
  void set_allocated_role(::protocol::RoleBaseInfo* role);

  // required int32 ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateRoleRspNet)
 private:
  void set_has_ret();
  void clear_has_ret();
  void set_has_role();
  void clear_has_role();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::RoleBaseInfo* role_;
  ::google::protobuf::int32 ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsCreateRoleRspNetImpl();
};
// -------------------------------------------------------------------

class EnterSceneReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EnterSceneReqNet) */ {
 public:
  EnterSceneReqNet();
  virtual ~EnterSceneReqNet();

  EnterSceneReqNet(const EnterSceneReqNet& from);

  inline EnterSceneReqNet& operator=(const EnterSceneReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterSceneReqNet(EnterSceneReqNet&& from) noexcept
    : EnterSceneReqNet() {
    *this = ::std::move(from);
  }

  inline EnterSceneReqNet& operator=(EnterSceneReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterSceneReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterSceneReqNet* internal_default_instance() {
    return reinterpret_cast<const EnterSceneReqNet*>(
               &_EnterSceneReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(EnterSceneReqNet* other);
  friend void swap(EnterSceneReqNet& a, EnterSceneReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterSceneReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterSceneReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterSceneReqNet& from);
  void MergeFrom(const EnterSceneReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterSceneReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 roleId = 1;
  bool has_roleid() const;
  void clear_roleid();
  static const int kRoleIdFieldNumber = 1;
  ::google::protobuf::int64 roleid() const;
  void set_roleid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:protocol.EnterSceneReqNet)
 private:
  void set_has_roleid();
  void clear_has_roleid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 roleid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEnterSceneReqNetImpl();
};
// -------------------------------------------------------------------

class EnterSceneRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EnterSceneRspNet) */ {
 public:
  EnterSceneRspNet();
  virtual ~EnterSceneRspNet();

  EnterSceneRspNet(const EnterSceneRspNet& from);

  inline EnterSceneRspNet& operator=(const EnterSceneRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EnterSceneRspNet(EnterSceneRspNet&& from) noexcept
    : EnterSceneRspNet() {
    *this = ::std::move(from);
  }

  inline EnterSceneRspNet& operator=(EnterSceneRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnterSceneRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EnterSceneRspNet* internal_default_instance() {
    return reinterpret_cast<const EnterSceneRspNet*>(
               &_EnterSceneRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(EnterSceneRspNet* other);
  friend void swap(EnterSceneRspNet& a, EnterSceneRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EnterSceneRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  EnterSceneRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EnterSceneRspNet& from);
  void MergeFrom(const EnterSceneRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EnterSceneRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.RoleInfo roleInfo = 2;
  bool has_roleinfo() const;
  void clear_roleinfo();
  static const int kRoleInfoFieldNumber = 2;
  const ::protocol::RoleInfo& roleinfo() const;
  ::protocol::RoleInfo* release_roleinfo();
  ::protocol::RoleInfo* mutable_roleinfo();
  void set_allocated_roleinfo(::protocol::RoleInfo* roleinfo);

  // required int32 ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.EnterSceneRspNet)
 private:
  void set_has_ret();
  void clear_has_ret();
  void set_has_roleinfo();
  void clear_has_roleinfo();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::RoleInfo* roleinfo_;
  ::google::protobuf::int32 ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEnterSceneRspNetImpl();
};
// -------------------------------------------------------------------

class BagNotifyNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BagNotifyNet) */ {
 public:
  BagNotifyNet();
  virtual ~BagNotifyNet();

  BagNotifyNet(const BagNotifyNet& from);

  inline BagNotifyNet& operator=(const BagNotifyNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BagNotifyNet(BagNotifyNet&& from) noexcept
    : BagNotifyNet() {
    *this = ::std::move(from);
  }

  inline BagNotifyNet& operator=(BagNotifyNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BagNotifyNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BagNotifyNet* internal_default_instance() {
    return reinterpret_cast<const BagNotifyNet*>(
               &_BagNotifyNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(BagNotifyNet* other);
  friend void swap(BagNotifyNet& a, BagNotifyNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BagNotifyNet* New() const PROTOBUF_FINAL { return New(NULL); }

  BagNotifyNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BagNotifyNet& from);
  void MergeFrom(const BagNotifyNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BagNotifyNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.ItemBag bag = 1;
  bool has_bag() const;
  void clear_bag();
  static const int kBagFieldNumber = 1;
  const ::protocol::ItemBag& bag() const;
  ::protocol::ItemBag* release_bag();
  ::protocol::ItemBag* mutable_bag();
  void set_allocated_bag(::protocol::ItemBag* bag);

  // @@protoc_insertion_point(class_scope:protocol.BagNotifyNet)
 private:
  void set_has_bag();
  void clear_has_bag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::ItemBag* bag_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsBagNotifyNetImpl();
};
// -------------------------------------------------------------------

class EquipBagNotifyNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipBagNotifyNet) */ {
 public:
  EquipBagNotifyNet();
  virtual ~EquipBagNotifyNet();

  EquipBagNotifyNet(const EquipBagNotifyNet& from);

  inline EquipBagNotifyNet& operator=(const EquipBagNotifyNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipBagNotifyNet(EquipBagNotifyNet&& from) noexcept
    : EquipBagNotifyNet() {
    *this = ::std::move(from);
  }

  inline EquipBagNotifyNet& operator=(EquipBagNotifyNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipBagNotifyNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipBagNotifyNet* internal_default_instance() {
    return reinterpret_cast<const EquipBagNotifyNet*>(
               &_EquipBagNotifyNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(EquipBagNotifyNet* other);
  friend void swap(EquipBagNotifyNet& a, EquipBagNotifyNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipBagNotifyNet* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipBagNotifyNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipBagNotifyNet& from);
  void MergeFrom(const EquipBagNotifyNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipBagNotifyNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.EquipBag bag = 1;
  bool has_bag() const;
  void clear_bag();
  static const int kBagFieldNumber = 1;
  const ::protocol::EquipBag& bag() const;
  ::protocol::EquipBag* release_bag();
  ::protocol::EquipBag* mutable_bag();
  void set_allocated_bag(::protocol::EquipBag* bag);

  // @@protoc_insertion_point(class_scope:protocol.EquipBagNotifyNet)
 private:
  void set_has_bag();
  void clear_has_bag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::protocol::EquipBag* bag_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipBagNotifyNetImpl();
};
// -------------------------------------------------------------------

class ErrorNotifyNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ErrorNotifyNet) */ {
 public:
  ErrorNotifyNet();
  virtual ~ErrorNotifyNet();

  ErrorNotifyNet(const ErrorNotifyNet& from);

  inline ErrorNotifyNet& operator=(const ErrorNotifyNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ErrorNotifyNet(ErrorNotifyNet&& from) noexcept
    : ErrorNotifyNet() {
    *this = ::std::move(from);
  }

  inline ErrorNotifyNet& operator=(ErrorNotifyNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorNotifyNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ErrorNotifyNet* internal_default_instance() {
    return reinterpret_cast<const ErrorNotifyNet*>(
               &_ErrorNotifyNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(ErrorNotifyNet* other);
  friend void swap(ErrorNotifyNet& a, ErrorNotifyNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ErrorNotifyNet* New() const PROTOBUF_FINAL { return New(NULL); }

  ErrorNotifyNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ErrorNotifyNet& from);
  void MergeFrom(const ErrorNotifyNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ErrorNotifyNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 err = 1;
  bool has_err() const;
  void clear_err();
  static const int kErrFieldNumber = 1;
  ::google::protobuf::int32 err() const;
  void set_err(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.ErrorNotifyNet)
 private:
  void set_has_err();
  void clear_has_err();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 err_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsErrorNotifyNetImpl();
};
// -------------------------------------------------------------------

class UpdLoginReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpdLoginReqNet) */ {
 public:
  UpdLoginReqNet();
  virtual ~UpdLoginReqNet();

  UpdLoginReqNet(const UpdLoginReqNet& from);

  inline UpdLoginReqNet& operator=(const UpdLoginReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdLoginReqNet(UpdLoginReqNet&& from) noexcept
    : UpdLoginReqNet() {
    *this = ::std::move(from);
  }

  inline UpdLoginReqNet& operator=(UpdLoginReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdLoginReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdLoginReqNet* internal_default_instance() {
    return reinterpret_cast<const UpdLoginReqNet*>(
               &_UpdLoginReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(UpdLoginReqNet* other);
  friend void swap(UpdLoginReqNet& a, UpdLoginReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdLoginReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdLoginReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdLoginReqNet& from);
  void MergeFrom(const UpdLoginReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdLoginReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 playerId = 2;
  bool has_playerid() const;
  void clear_playerid();
  static const int kPlayerIdFieldNumber = 2;
  ::google::protobuf::int64 playerid() const;
  void set_playerid(::google::protobuf::int64 value);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.UpdLoginReqNet)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_playerid();
  void clear_has_playerid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int64 playerid_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUpdLoginReqNetImpl();
};
// -------------------------------------------------------------------

class UpdLoginRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpdLoginRspNet) */ {
 public:
  UpdLoginRspNet();
  virtual ~UpdLoginRspNet();

  UpdLoginRspNet(const UpdLoginRspNet& from);

  inline UpdLoginRspNet& operator=(const UpdLoginRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdLoginRspNet(UpdLoginRspNet&& from) noexcept
    : UpdLoginRspNet() {
    *this = ::std::move(from);
  }

  inline UpdLoginRspNet& operator=(UpdLoginRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdLoginRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdLoginRspNet* internal_default_instance() {
    return reinterpret_cast<const UpdLoginRspNet*>(
               &_UpdLoginRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(UpdLoginRspNet* other);
  friend void swap(UpdLoginRspNet& a, UpdLoginRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdLoginRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdLoginRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdLoginRspNet& from);
  void MergeFrom(const UpdLoginRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdLoginRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 kcpId = 1;
  bool has_kcpid() const;
  void clear_kcpid();
  static const int kKcpIdFieldNumber = 1;
  ::google::protobuf::int32 kcpid() const;
  void set_kcpid(::google::protobuf::int32 value);

  // required int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.UpdLoginRspNet)
 private:
  void set_has_kcpid();
  void clear_has_kcpid();
  void set_has_id();
  void clear_has_id();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 kcpid_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUpdLoginRspNetImpl();
};
// -------------------------------------------------------------------

class UpdTestReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpdTestReqNet) */ {
 public:
  UpdTestReqNet();
  virtual ~UpdTestReqNet();

  UpdTestReqNet(const UpdTestReqNet& from);

  inline UpdTestReqNet& operator=(const UpdTestReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdTestReqNet(UpdTestReqNet&& from) noexcept
    : UpdTestReqNet() {
    *this = ::std::move(from);
  }

  inline UpdTestReqNet& operator=(UpdTestReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdTestReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdTestReqNet* internal_default_instance() {
    return reinterpret_cast<const UpdTestReqNet*>(
               &_UpdTestReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(UpdTestReqNet* other);
  friend void swap(UpdTestReqNet& a, UpdTestReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdTestReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdTestReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdTestReqNet& from);
  void MergeFrom(const UpdTestReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdTestReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 dataId = 1;
  bool has_dataid() const;
  void clear_dataid();
  static const int kDataIdFieldNumber = 1;
  ::google::protobuf::int32 dataid() const;
  void set_dataid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.UpdTestReqNet)
 private:
  void set_has_dataid();
  void clear_has_dataid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 dataid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUpdTestReqNetImpl();
};
// -------------------------------------------------------------------

class UpdTestRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.UpdTestRspNet) */ {
 public:
  UpdTestRspNet();
  virtual ~UpdTestRspNet();

  UpdTestRspNet(const UpdTestRspNet& from);

  inline UpdTestRspNet& operator=(const UpdTestRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdTestRspNet(UpdTestRspNet&& from) noexcept
    : UpdTestRspNet() {
    *this = ::std::move(from);
  }

  inline UpdTestRspNet& operator=(UpdTestRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdTestRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdTestRspNet* internal_default_instance() {
    return reinterpret_cast<const UpdTestRspNet*>(
               &_UpdTestRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(UpdTestRspNet* other);
  friend void swap(UpdTestRspNet& a, UpdTestRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdTestRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  UpdTestRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UpdTestRspNet& from);
  void MergeFrom(const UpdTestRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UpdTestRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 dataId = 1;
  bool has_dataid() const;
  void clear_dataid();
  static const int kDataIdFieldNumber = 1;
  ::google::protobuf::int32 dataid() const;
  void set_dataid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.UpdTestRspNet)
 private:
  void set_has_dataid();
  void clear_has_dataid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 dataid_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsUpdTestRspNetImpl();
};
// -------------------------------------------------------------------

class BuyRoleSoltReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BuyRoleSoltReqNet) */ {
 public:
  BuyRoleSoltReqNet();
  virtual ~BuyRoleSoltReqNet();

  BuyRoleSoltReqNet(const BuyRoleSoltReqNet& from);

  inline BuyRoleSoltReqNet& operator=(const BuyRoleSoltReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyRoleSoltReqNet(BuyRoleSoltReqNet&& from) noexcept
    : BuyRoleSoltReqNet() {
    *this = ::std::move(from);
  }

  inline BuyRoleSoltReqNet& operator=(BuyRoleSoltReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyRoleSoltReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyRoleSoltReqNet* internal_default_instance() {
    return reinterpret_cast<const BuyRoleSoltReqNet*>(
               &_BuyRoleSoltReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(BuyRoleSoltReqNet* other);
  friend void swap(BuyRoleSoltReqNet& a, BuyRoleSoltReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyRoleSoltReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  BuyRoleSoltReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuyRoleSoltReqNet& from);
  void MergeFrom(const BuyRoleSoltReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuyRoleSoltReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.BuyRoleSoltReqNet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsBuyRoleSoltReqNetImpl();
};
// -------------------------------------------------------------------

class BuyRoleSoltRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BuyRoleSoltRspNet) */ {
 public:
  BuyRoleSoltRspNet();
  virtual ~BuyRoleSoltRspNet();

  BuyRoleSoltRspNet(const BuyRoleSoltRspNet& from);

  inline BuyRoleSoltRspNet& operator=(const BuyRoleSoltRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyRoleSoltRspNet(BuyRoleSoltRspNet&& from) noexcept
    : BuyRoleSoltRspNet() {
    *this = ::std::move(from);
  }

  inline BuyRoleSoltRspNet& operator=(BuyRoleSoltRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyRoleSoltRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyRoleSoltRspNet* internal_default_instance() {
    return reinterpret_cast<const BuyRoleSoltRspNet*>(
               &_BuyRoleSoltRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(BuyRoleSoltRspNet* other);
  friend void swap(BuyRoleSoltRspNet& a, BuyRoleSoltRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyRoleSoltRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  BuyRoleSoltRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuyRoleSoltRspNet& from);
  void MergeFrom(const BuyRoleSoltRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuyRoleSoltRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 soltCount = 1;
  bool has_soltcount() const;
  void clear_soltcount();
  static const int kSoltCountFieldNumber = 1;
  ::google::protobuf::int32 soltcount() const;
  void set_soltcount(::google::protobuf::int32 value);

  // required int32 ret = 2;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 2;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.BuyRoleSoltRspNet)
 private:
  void set_has_soltcount();
  void clear_has_soltcount();
  void set_has_ret();
  void clear_has_ret();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 soltcount_;
  ::google::protobuf::int32 ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsBuyRoleSoltRspNetImpl();
};
// -------------------------------------------------------------------

class GMCMDReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GMCMDReqNet) */ {
 public:
  GMCMDReqNet();
  virtual ~GMCMDReqNet();

  GMCMDReqNet(const GMCMDReqNet& from);

  inline GMCMDReqNet& operator=(const GMCMDReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GMCMDReqNet(GMCMDReqNet&& from) noexcept
    : GMCMDReqNet() {
    *this = ::std::move(from);
  }

  inline GMCMDReqNet& operator=(GMCMDReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMCMDReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GMCMDReqNet* internal_default_instance() {
    return reinterpret_cast<const GMCMDReqNet*>(
               &_GMCMDReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(GMCMDReqNet* other);
  friend void swap(GMCMDReqNet& a, GMCMDReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GMCMDReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  GMCMDReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GMCMDReqNet& from);
  void MergeFrom(const GMCMDReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GMCMDReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cmd = 1;
  bool has_cmd() const;
  void clear_cmd();
  static const int kCmdFieldNumber = 1;
  const ::std::string& cmd() const;
  void set_cmd(const ::std::string& value);
  #if LANG_CXX11
  void set_cmd(::std::string&& value);
  #endif
  void set_cmd(const char* value);
  void set_cmd(const char* value, size_t size);
  ::std::string* mutable_cmd();
  ::std::string* release_cmd();
  void set_allocated_cmd(::std::string* cmd);

  // @@protoc_insertion_point(class_scope:protocol.GMCMDReqNet)
 private:
  void set_has_cmd();
  void clear_has_cmd();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr cmd_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsGMCMDReqNetImpl();
};
// -------------------------------------------------------------------

class GMCMDRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.GMCMDRspNet) */ {
 public:
  GMCMDRspNet();
  virtual ~GMCMDRspNet();

  GMCMDRspNet(const GMCMDRspNet& from);

  inline GMCMDRspNet& operator=(const GMCMDRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GMCMDRspNet(GMCMDRspNet&& from) noexcept
    : GMCMDRspNet() {
    *this = ::std::move(from);
  }

  inline GMCMDRspNet& operator=(GMCMDRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GMCMDRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GMCMDRspNet* internal_default_instance() {
    return reinterpret_cast<const GMCMDRspNet*>(
               &_GMCMDRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(GMCMDRspNet* other);
  friend void swap(GMCMDRspNet& a, GMCMDRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GMCMDRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  GMCMDRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GMCMDRspNet& from);
  void MergeFrom(const GMCMDRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GMCMDRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  const ::std::string& ret() const;
  void set_ret(const ::std::string& value);
  #if LANG_CXX11
  void set_ret(::std::string&& value);
  #endif
  void set_ret(const char* value);
  void set_ret(const char* value, size_t size);
  ::std::string* mutable_ret();
  ::std::string* release_ret();
  void set_allocated_ret(::std::string* ret);

  // @@protoc_insertion_point(class_scope:protocol.GMCMDRspNet)
 private:
  void set_has_ret();
  void clear_has_ret();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ret_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsGMCMDRspNetImpl();
};
// -------------------------------------------------------------------

class ItemChangeNotifyNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.ItemChangeNotifyNet) */ {
 public:
  ItemChangeNotifyNet();
  virtual ~ItemChangeNotifyNet();

  ItemChangeNotifyNet(const ItemChangeNotifyNet& from);

  inline ItemChangeNotifyNet& operator=(const ItemChangeNotifyNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ItemChangeNotifyNet(ItemChangeNotifyNet&& from) noexcept
    : ItemChangeNotifyNet() {
    *this = ::std::move(from);
  }

  inline ItemChangeNotifyNet& operator=(ItemChangeNotifyNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemChangeNotifyNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ItemChangeNotifyNet* internal_default_instance() {
    return reinterpret_cast<const ItemChangeNotifyNet*>(
               &_ItemChangeNotifyNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(ItemChangeNotifyNet* other);
  friend void swap(ItemChangeNotifyNet& a, ItemChangeNotifyNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ItemChangeNotifyNet* New() const PROTOBUF_FINAL { return New(NULL); }

  ItemChangeNotifyNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ItemChangeNotifyNet& from);
  void MergeFrom(const ItemChangeNotifyNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ItemChangeNotifyNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.ItemChangeInfo infos = 1;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 1;
  const ::protocol::ItemChangeInfo& infos(int index) const;
  ::protocol::ItemChangeInfo* mutable_infos(int index);
  ::protocol::ItemChangeInfo* add_infos();
  ::google::protobuf::RepeatedPtrField< ::protocol::ItemChangeInfo >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::protocol::ItemChangeInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:protocol.ItemChangeNotifyNet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ItemChangeInfo > infos_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsItemChangeNotifyNetImpl();
};
// -------------------------------------------------------------------

class EquipChangeNotifyNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.EquipChangeNotifyNet) */ {
 public:
  EquipChangeNotifyNet();
  virtual ~EquipChangeNotifyNet();

  EquipChangeNotifyNet(const EquipChangeNotifyNet& from);

  inline EquipChangeNotifyNet& operator=(const EquipChangeNotifyNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EquipChangeNotifyNet(EquipChangeNotifyNet&& from) noexcept
    : EquipChangeNotifyNet() {
    *this = ::std::move(from);
  }

  inline EquipChangeNotifyNet& operator=(EquipChangeNotifyNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EquipChangeNotifyNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EquipChangeNotifyNet* internal_default_instance() {
    return reinterpret_cast<const EquipChangeNotifyNet*>(
               &_EquipChangeNotifyNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(EquipChangeNotifyNet* other);
  friend void swap(EquipChangeNotifyNet& a, EquipChangeNotifyNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EquipChangeNotifyNet* New() const PROTOBUF_FINAL { return New(NULL); }

  EquipChangeNotifyNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EquipChangeNotifyNet& from);
  void MergeFrom(const EquipChangeNotifyNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EquipChangeNotifyNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.EquipChangeInfo infos = 1;
  int infos_size() const;
  void clear_infos();
  static const int kInfosFieldNumber = 1;
  const ::protocol::EquipChangeInfo& infos(int index) const;
  ::protocol::EquipChangeInfo* mutable_infos(int index);
  ::protocol::EquipChangeInfo* add_infos();
  ::google::protobuf::RepeatedPtrField< ::protocol::EquipChangeInfo >*
      mutable_infos();
  const ::google::protobuf::RepeatedPtrField< ::protocol::EquipChangeInfo >&
      infos() const;

  // @@protoc_insertion_point(class_scope:protocol.EquipChangeNotifyNet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::EquipChangeInfo > infos_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsEquipChangeNotifyNetImpl();
};
// -------------------------------------------------------------------

class BuyBagSoltReqNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BuyBagSoltReqNet) */ {
 public:
  BuyBagSoltReqNet();
  virtual ~BuyBagSoltReqNet();

  BuyBagSoltReqNet(const BuyBagSoltReqNet& from);

  inline BuyBagSoltReqNet& operator=(const BuyBagSoltReqNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyBagSoltReqNet(BuyBagSoltReqNet&& from) noexcept
    : BuyBagSoltReqNet() {
    *this = ::std::move(from);
  }

  inline BuyBagSoltReqNet& operator=(BuyBagSoltReqNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyBagSoltReqNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyBagSoltReqNet* internal_default_instance() {
    return reinterpret_cast<const BuyBagSoltReqNet*>(
               &_BuyBagSoltReqNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(BuyBagSoltReqNet* other);
  friend void swap(BuyBagSoltReqNet& a, BuyBagSoltReqNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyBagSoltReqNet* New() const PROTOBUF_FINAL { return New(NULL); }

  BuyBagSoltReqNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuyBagSoltReqNet& from);
  void MergeFrom(const BuyBagSoltReqNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuyBagSoltReqNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.BuyBagSoltReqNet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsBuyBagSoltReqNetImpl();
};
// -------------------------------------------------------------------

class BuyBagSoltRspNet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protocol.BuyBagSoltRspNet) */ {
 public:
  BuyBagSoltRspNet();
  virtual ~BuyBagSoltRspNet();

  BuyBagSoltRspNet(const BuyBagSoltRspNet& from);

  inline BuyBagSoltRspNet& operator=(const BuyBagSoltRspNet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BuyBagSoltRspNet(BuyBagSoltRspNet&& from) noexcept
    : BuyBagSoltRspNet() {
    *this = ::std::move(from);
  }

  inline BuyBagSoltRspNet& operator=(BuyBagSoltRspNet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuyBagSoltRspNet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BuyBagSoltRspNet* internal_default_instance() {
    return reinterpret_cast<const BuyBagSoltRspNet*>(
               &_BuyBagSoltRspNet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(BuyBagSoltRspNet* other);
  friend void swap(BuyBagSoltRspNet& a, BuyBagSoltRspNet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BuyBagSoltRspNet* New() const PROTOBUF_FINAL { return New(NULL); }

  BuyBagSoltRspNet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BuyBagSoltRspNet& from);
  void MergeFrom(const BuyBagSoltRspNet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BuyBagSoltRspNet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 ret = 1;
  bool has_ret() const;
  void clear_ret();
  static const int kRetFieldNumber = 1;
  ::google::protobuf::int32 ret() const;
  void set_ret(::google::protobuf::int32 value);

  // required int32 consumptionsBag = 2;
  bool has_consumptionsbag() const;
  void clear_consumptionsbag();
  static const int kConsumptionsBagFieldNumber = 2;
  ::google::protobuf::int32 consumptionsbag() const;
  void set_consumptionsbag(::google::protobuf::int32 value);

  // required int32 materialsBag = 3;
  bool has_materialsbag() const;
  void clear_materialsbag();
  static const int kMaterialsBagFieldNumber = 3;
  ::google::protobuf::int32 materialsbag() const;
  void set_materialsbag(::google::protobuf::int32 value);

  // required int32 questsBag = 4;
  bool has_questsbag() const;
  void clear_questsbag();
  static const int kQuestsBagFieldNumber = 4;
  ::google::protobuf::int32 questsbag() const;
  void set_questsbag(::google::protobuf::int32 value);

  // required int32 equipsBag = 5;
  bool has_equipsbag() const;
  void clear_equipsbag();
  static const int kEquipsBagFieldNumber = 5;
  ::google::protobuf::int32 equipsbag() const;
  void set_equipsbag(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocol.BuyBagSoltRspNet)
 private:
  void set_has_ret();
  void clear_has_ret();
  void set_has_consumptionsbag();
  void clear_has_consumptionsbag();
  void set_has_materialsbag();
  void clear_has_materialsbag();
  void set_has_questsbag();
  void clear_has_questsbag();
  void set_has_equipsbag();
  void clear_has_equipsbag();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 ret_;
  ::google::protobuf::int32 consumptionsbag_;
  ::google::protobuf::int32 materialsbag_;
  ::google::protobuf::int32 questsbag_;
  ::google::protobuf::int32 equipsbag_;
  friend struct ::protobuf_proto_2fmsg_5fnet_2eproto::TableStruct;
  friend void ::protobuf_proto_2fmsg_5fnet_2eproto::InitDefaultsBuyBagSoltRspNetImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StringNet

// required string value = 1;
inline bool StringNet::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringNet::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringNet::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringNet::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StringNet::value() const {
  // @@protoc_insertion_point(field_get:protocol.StringNet.value)
  return value_.GetNoArena();
}
inline void StringNet::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.StringNet.value)
}
#if LANG_CXX11
inline void StringNet::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.StringNet.value)
}
#endif
inline void StringNet::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.StringNet.value)
}
inline void StringNet::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.StringNet.value)
}
inline ::std::string* StringNet::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:protocol.StringNet.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringNet::release_value() {
  // @@protoc_insertion_point(field_release:protocol.StringNet.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringNet::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:protocol.StringNet.value)
}

// -------------------------------------------------------------------

// Uint32Net

// required uint32 value = 1;
inline bool Uint32Net::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uint32Net::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uint32Net::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uint32Net::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Uint32Net::value() const {
  // @@protoc_insertion_point(field_get:protocol.Uint32Net.value)
  return value_;
}
inline void Uint32Net::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Uint32Net.value)
}

// -------------------------------------------------------------------

// Uint32ListNet

// repeated uint32 valueList = 1;
inline int Uint32ListNet::valuelist_size() const {
  return valuelist_.size();
}
inline void Uint32ListNet::clear_valuelist() {
  valuelist_.Clear();
}
inline ::google::protobuf::uint32 Uint32ListNet::valuelist(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Uint32ListNet.valueList)
  return valuelist_.Get(index);
}
inline void Uint32ListNet::set_valuelist(int index, ::google::protobuf::uint32 value) {
  valuelist_.Set(index, value);
  // @@protoc_insertion_point(field_set:protocol.Uint32ListNet.valueList)
}
inline void Uint32ListNet::add_valuelist(::google::protobuf::uint32 value) {
  valuelist_.Add(value);
  // @@protoc_insertion_point(field_add:protocol.Uint32ListNet.valueList)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
Uint32ListNet::valuelist() const {
  // @@protoc_insertion_point(field_list:protocol.Uint32ListNet.valueList)
  return valuelist_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
Uint32ListNet::mutable_valuelist() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Uint32ListNet.valueList)
  return &valuelist_;
}

// -------------------------------------------------------------------

// Uint64Net

// required uint64 value = 1;
inline bool Uint64Net::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uint64Net::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uint64Net::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uint64Net::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 Uint64Net::value() const {
  // @@protoc_insertion_point(field_get:protocol.Uint64Net.value)
  return value_;
}
inline void Uint64Net::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Uint64Net.value)
}

// -------------------------------------------------------------------

// DoubleInt32Net

// required int32 key = 1;
inline bool DoubleInt32Net::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleInt32Net::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleInt32Net::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleInt32Net::clear_key() {
  key_ = 0;
  clear_has_key();
}
inline ::google::protobuf::int32 DoubleInt32Net::key() const {
  // @@protoc_insertion_point(field_get:protocol.DoubleInt32Net.key)
  return key_;
}
inline void DoubleInt32Net::set_key(::google::protobuf::int32 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:protocol.DoubleInt32Net.key)
}

// required int32 value = 2;
inline bool DoubleInt32Net::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleInt32Net::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleInt32Net::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleInt32Net::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 DoubleInt32Net::value() const {
  // @@protoc_insertion_point(field_get:protocol.DoubleInt32Net.value)
  return value_;
}
inline void DoubleInt32Net::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.DoubleInt32Net.value)
}

// -------------------------------------------------------------------

// DoubleUint64Net

// required uint64 key = 1;
inline bool DoubleUint64Net::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleUint64Net::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleUint64Net::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleUint64Net::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
  clear_has_key();
}
inline ::google::protobuf::uint64 DoubleUint64Net::key() const {
  // @@protoc_insertion_point(field_get:protocol.DoubleUint64Net.key)
  return key_;
}
inline void DoubleUint64Net::set_key(::google::protobuf::uint64 value) {
  set_has_key();
  key_ = value;
  // @@protoc_insertion_point(field_set:protocol.DoubleUint64Net.key)
}

// required uint64 value = 2;
inline bool DoubleUint64Net::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleUint64Net::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleUint64Net::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleUint64Net::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 DoubleUint64Net::value() const {
  // @@protoc_insertion_point(field_get:protocol.DoubleUint64Net.value)
  return value_;
}
inline void DoubleUint64Net::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.DoubleUint64Net.value)
}

// -------------------------------------------------------------------

// ServerInfo

// required string serverIp = 1;
inline bool ServerInfo::has_serverip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfo::set_has_serverip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfo::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfo::clear_serverip() {
  serverip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serverip();
}
inline const ::std::string& ServerInfo::serverip() const {
  // @@protoc_insertion_point(field_get:protocol.ServerInfo.serverIp)
  return serverip_.GetNoArena();
}
inline void ServerInfo::set_serverip(const ::std::string& value) {
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.ServerInfo.serverIp)
}
#if LANG_CXX11
inline void ServerInfo::set_serverip(::std::string&& value) {
  set_has_serverip();
  serverip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.ServerInfo.serverIp)
}
#endif
inline void ServerInfo::set_serverip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.ServerInfo.serverIp)
}
inline void ServerInfo::set_serverip(const char* value, size_t size) {
  set_has_serverip();
  serverip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.ServerInfo.serverIp)
}
inline ::std::string* ServerInfo::mutable_serverip() {
  set_has_serverip();
  // @@protoc_insertion_point(field_mutable:protocol.ServerInfo.serverIp)
  return serverip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerInfo::release_serverip() {
  // @@protoc_insertion_point(field_release:protocol.ServerInfo.serverIp)
  clear_has_serverip();
  return serverip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerInfo::set_allocated_serverip(::std::string* serverip) {
  if (serverip != NULL) {
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serverip);
  // @@protoc_insertion_point(field_set_allocated:protocol.ServerInfo.serverIp)
}

// required int32 serverPort = 2;
inline bool ServerInfo::has_serverport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfo::set_has_serverport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfo::clear_has_serverport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfo::clear_serverport() {
  serverport_ = 0;
  clear_has_serverport();
}
inline ::google::protobuf::int32 ServerInfo::serverport() const {
  // @@protoc_insertion_point(field_get:protocol.ServerInfo.serverPort)
  return serverport_;
}
inline void ServerInfo::set_serverport(::google::protobuf::int32 value) {
  set_has_serverport();
  serverport_ = value;
  // @@protoc_insertion_point(field_set:protocol.ServerInfo.serverPort)
}

// optional int32 serverId = 3;
inline bool ServerInfo::has_serverid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfo::set_has_serverid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfo::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfo::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 ServerInfo::serverid() const {
  // @@protoc_insertion_point(field_get:protocol.ServerInfo.serverId)
  return serverid_;
}
inline void ServerInfo::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
  // @@protoc_insertion_point(field_set:protocol.ServerInfo.serverId)
}

// -------------------------------------------------------------------

// MapPos

// required int64 x = 1;
inline bool MapPos::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapPos::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapPos::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapPos::clear_x() {
  x_ = GOOGLE_LONGLONG(0);
  clear_has_x();
}
inline ::google::protobuf::int64 MapPos::x() const {
  // @@protoc_insertion_point(field_get:protocol.MapPos.x)
  return x_;
}
inline void MapPos::set_x(::google::protobuf::int64 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:protocol.MapPos.x)
}

// required int64 y = 2;
inline bool MapPos::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapPos::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapPos::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapPos::clear_y() {
  y_ = GOOGLE_LONGLONG(0);
  clear_has_y();
}
inline ::google::protobuf::int64 MapPos::y() const {
  // @@protoc_insertion_point(field_get:protocol.MapPos.y)
  return y_;
}
inline void MapPos::set_y(::google::protobuf::int64 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:protocol.MapPos.y)
}

// required int64 z = 3;
inline bool MapPos::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapPos::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapPos::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapPos::clear_z() {
  z_ = GOOGLE_LONGLONG(0);
  clear_has_z();
}
inline ::google::protobuf::int64 MapPos::z() const {
  // @@protoc_insertion_point(field_get:protocol.MapPos.z)
  return z_;
}
inline void MapPos::set_z(::google::protobuf::int64 value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:protocol.MapPos.z)
}

// -------------------------------------------------------------------

// PlayerBaseInfo

// required int64 playerId = 1;
inline bool PlayerBaseInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerBaseInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerBaseInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerBaseInfo::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 PlayerBaseInfo::playerid() const {
  // @@protoc_insertion_point(field_get:protocol.PlayerBaseInfo.playerId)
  return playerid_;
}
inline void PlayerBaseInfo::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:protocol.PlayerBaseInfo.playerId)
}

// required int32 diamond = 2;
inline bool PlayerBaseInfo::has_diamond() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerBaseInfo::set_has_diamond() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerBaseInfo::clear_has_diamond() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerBaseInfo::clear_diamond() {
  diamond_ = 0;
  clear_has_diamond();
}
inline ::google::protobuf::int32 PlayerBaseInfo::diamond() const {
  // @@protoc_insertion_point(field_get:protocol.PlayerBaseInfo.diamond)
  return diamond_;
}
inline void PlayerBaseInfo::set_diamond(::google::protobuf::int32 value) {
  set_has_diamond();
  diamond_ = value;
  // @@protoc_insertion_point(field_set:protocol.PlayerBaseInfo.diamond)
}

// required int32 vipLevel = 3;
inline bool PlayerBaseInfo::has_viplevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerBaseInfo::set_has_viplevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerBaseInfo::clear_has_viplevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerBaseInfo::clear_viplevel() {
  viplevel_ = 0;
  clear_has_viplevel();
}
inline ::google::protobuf::int32 PlayerBaseInfo::viplevel() const {
  // @@protoc_insertion_point(field_get:protocol.PlayerBaseInfo.vipLevel)
  return viplevel_;
}
inline void PlayerBaseInfo::set_viplevel(::google::protobuf::int32 value) {
  set_has_viplevel();
  viplevel_ = value;
  // @@protoc_insertion_point(field_set:protocol.PlayerBaseInfo.vipLevel)
}

// -------------------------------------------------------------------

// RoleBaseInfo

// required int64 roleId = 1;
inline bool RoleBaseInfo::has_roleid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleBaseInfo::set_has_roleid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleBaseInfo::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleBaseInfo::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 RoleBaseInfo::roleid() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.roleId)
  return roleid_;
}
inline void RoleBaseInfo::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.roleId)
}

// required int32 jobId = 2;
inline bool RoleBaseInfo::has_jobid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleBaseInfo::set_has_jobid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleBaseInfo::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleBaseInfo::clear_jobid() {
  jobid_ = 0;
  clear_has_jobid();
}
inline ::google::protobuf::int32 RoleBaseInfo::jobid() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.jobId)
  return jobid_;
}
inline void RoleBaseInfo::set_jobid(::google::protobuf::int32 value) {
  set_has_jobid();
  jobid_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.jobId)
}

// required int32 sex = 3;
inline bool RoleBaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleBaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleBaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleBaseInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 RoleBaseInfo::sex() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.sex)
  return sex_;
}
inline void RoleBaseInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.sex)
}

// required string name = 4;
inline bool RoleBaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleBaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleBaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleBaseInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RoleBaseInfo::name() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.name)
  return name_.GetNoArena();
}
inline void RoleBaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.name)
}
#if LANG_CXX11
inline void RoleBaseInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.RoleBaseInfo.name)
}
#endif
inline void RoleBaseInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.RoleBaseInfo.name)
}
inline void RoleBaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.RoleBaseInfo.name)
}
inline ::std::string* RoleBaseInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:protocol.RoleBaseInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoleBaseInfo::release_name() {
  // @@protoc_insertion_point(field_release:protocol.RoleBaseInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoleBaseInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.RoleBaseInfo.name)
}

// required int32 level = 5;
inline bool RoleBaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleBaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleBaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleBaseInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 RoleBaseInfo::level() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.level)
  return level_;
}
inline void RoleBaseInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.level)
}

// optional .protocol.EquipInfo equips = 6;
inline bool RoleBaseInfo::has_equips() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleBaseInfo::set_has_equips() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleBaseInfo::clear_has_equips() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleBaseInfo::clear_equips() {
  if (equips_ != NULL) equips_->Clear();
  clear_has_equips();
}
inline const ::protocol::EquipInfo& RoleBaseInfo::equips() const {
  const ::protocol::EquipInfo* p = equips_;
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.equips)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::EquipInfo*>(
      &::protocol::_EquipInfo_default_instance_);
}
inline ::protocol::EquipInfo* RoleBaseInfo::release_equips() {
  // @@protoc_insertion_point(field_release:protocol.RoleBaseInfo.equips)
  clear_has_equips();
  ::protocol::EquipInfo* temp = equips_;
  equips_ = NULL;
  return temp;
}
inline ::protocol::EquipInfo* RoleBaseInfo::mutable_equips() {
  set_has_equips();
  if (equips_ == NULL) {
    equips_ = new ::protocol::EquipInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.RoleBaseInfo.equips)
  return equips_;
}
inline void RoleBaseInfo::set_allocated_equips(::protocol::EquipInfo* equips) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete equips_;
  }
  if (equips) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      equips = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, equips, submessage_arena);
    }
    set_has_equips();
  } else {
    clear_has_equips();
  }
  equips_ = equips;
  // @@protoc_insertion_point(field_set_allocated:protocol.RoleBaseInfo.equips)
}

// required int32 mainCityId = 7;
inline bool RoleBaseInfo::has_maincityid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RoleBaseInfo::set_has_maincityid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RoleBaseInfo::clear_has_maincityid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RoleBaseInfo::clear_maincityid() {
  maincityid_ = 0;
  clear_has_maincityid();
}
inline ::google::protobuf::int32 RoleBaseInfo::maincityid() const {
  // @@protoc_insertion_point(field_get:protocol.RoleBaseInfo.mainCityId)
  return maincityid_;
}
inline void RoleBaseInfo::set_maincityid(::google::protobuf::int32 value) {
  set_has_maincityid();
  maincityid_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleBaseInfo.mainCityId)
}

// -------------------------------------------------------------------

// ItemBaseInfo

// required int32 itemType = 1;
inline bool ItemBaseInfo::has_itemtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ItemBaseInfo::set_has_itemtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ItemBaseInfo::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ItemBaseInfo::clear_itemtype() {
  itemtype_ = 0;
  clear_has_itemtype();
}
inline ::google::protobuf::int32 ItemBaseInfo::itemtype() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBaseInfo.itemType)
  return itemtype_;
}
inline void ItemBaseInfo::set_itemtype(::google::protobuf::int32 value) {
  set_has_itemtype();
  itemtype_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBaseInfo.itemType)
}

// required int64 id = 2;
inline bool ItemBaseInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemBaseInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemBaseInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemBaseInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 ItemBaseInfo::id() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBaseInfo.id)
  return id_;
}
inline void ItemBaseInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBaseInfo.id)
}

// required int64 count = 3;
inline bool ItemBaseInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemBaseInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemBaseInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemBaseInfo::clear_count() {
  count_ = GOOGLE_LONGLONG(0);
  clear_has_count();
}
inline ::google::protobuf::int64 ItemBaseInfo::count() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBaseInfo.count)
  return count_;
}
inline void ItemBaseInfo::set_count(::google::protobuf::int64 value) {
  set_has_count();
  count_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBaseInfo.count)
}

// required int64 uid = 4;
inline bool ItemBaseInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemBaseInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemBaseInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemBaseInfo::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 ItemBaseInfo::uid() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBaseInfo.uid)
  return uid_;
}
inline void ItemBaseInfo::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBaseInfo.uid)
}

// -------------------------------------------------------------------

// ItemInfo

// required .protocol.ItemBaseInfo baseInfo = 1;
inline bool ItemInfo::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemInfo::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemInfo::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemInfo::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->Clear();
  clear_has_baseinfo();
}
inline const ::protocol::ItemBaseInfo& ItemInfo::baseinfo() const {
  const ::protocol::ItemBaseInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:protocol.ItemInfo.baseInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ItemBaseInfo*>(
      &::protocol::_ItemBaseInfo_default_instance_);
}
inline ::protocol::ItemBaseInfo* ItemInfo::release_baseinfo() {
  // @@protoc_insertion_point(field_release:protocol.ItemInfo.baseInfo)
  clear_has_baseinfo();
  ::protocol::ItemBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline ::protocol::ItemBaseInfo* ItemInfo::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) {
    baseinfo_ = new ::protocol::ItemBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ItemInfo.baseInfo)
  return baseinfo_;
}
inline void ItemInfo::set_allocated_baseinfo(::protocol::ItemBaseInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.ItemInfo.baseInfo)
}

// -------------------------------------------------------------------

// ItemChangeInfo

// required .protocol.ItemInfo info = 1;
inline bool ItemChangeInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemChangeInfo::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemChangeInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemChangeInfo::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::protocol::ItemInfo& ItemChangeInfo::info() const {
  const ::protocol::ItemInfo* p = info_;
  // @@protoc_insertion_point(field_get:protocol.ItemChangeInfo.info)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ItemInfo*>(
      &::protocol::_ItemInfo_default_instance_);
}
inline ::protocol::ItemInfo* ItemChangeInfo::release_info() {
  // @@protoc_insertion_point(field_release:protocol.ItemChangeInfo.info)
  clear_has_info();
  ::protocol::ItemInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::protocol::ItemInfo* ItemChangeInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::protocol::ItemInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ItemChangeInfo.info)
  return info_;
}
inline void ItemChangeInfo::set_allocated_info(::protocol::ItemInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:protocol.ItemChangeInfo.info)
}

// required int32 change = 2;
inline bool ItemChangeInfo::has_change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemChangeInfo::set_has_change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemChangeInfo::clear_has_change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemChangeInfo::clear_change() {
  change_ = 0;
  clear_has_change();
}
inline ::google::protobuf::int32 ItemChangeInfo::change() const {
  // @@protoc_insertion_point(field_get:protocol.ItemChangeInfo.change)
  return change_;
}
inline void ItemChangeInfo::set_change(::google::protobuf::int32 value) {
  set_has_change();
  change_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemChangeInfo.change)
}

// -------------------------------------------------------------------

// ItemBag

// repeated .protocol.ItemInfo infos = 1;
inline int ItemBag::infos_size() const {
  return infos_.size();
}
inline void ItemBag::clear_infos() {
  infos_.Clear();
}
inline const ::protocol::ItemInfo& ItemBag::infos(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ItemBag.infos)
  return infos_.Get(index);
}
inline ::protocol::ItemInfo* ItemBag::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ItemBag.infos)
  return infos_.Mutable(index);
}
inline ::protocol::ItemInfo* ItemBag::add_infos() {
  // @@protoc_insertion_point(field_add:protocol.ItemBag.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ItemInfo >*
ItemBag::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ItemBag.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ItemInfo >&
ItemBag::infos() const {
  // @@protoc_insertion_point(field_list:protocol.ItemBag.infos)
  return infos_;
}

// required int32 consumptionsBag = 2;
inline bool ItemBag::has_consumptionsbag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemBag::set_has_consumptionsbag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemBag::clear_has_consumptionsbag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemBag::clear_consumptionsbag() {
  consumptionsbag_ = 0;
  clear_has_consumptionsbag();
}
inline ::google::protobuf::int32 ItemBag::consumptionsbag() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBag.consumptionsBag)
  return consumptionsbag_;
}
inline void ItemBag::set_consumptionsbag(::google::protobuf::int32 value) {
  set_has_consumptionsbag();
  consumptionsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBag.consumptionsBag)
}

// required int32 materialsBag = 3;
inline bool ItemBag::has_materialsbag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemBag::set_has_materialsbag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemBag::clear_has_materialsbag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemBag::clear_materialsbag() {
  materialsbag_ = 0;
  clear_has_materialsbag();
}
inline ::google::protobuf::int32 ItemBag::materialsbag() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBag.materialsBag)
  return materialsbag_;
}
inline void ItemBag::set_materialsbag(::google::protobuf::int32 value) {
  set_has_materialsbag();
  materialsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBag.materialsBag)
}

// required int32 questsBag = 4;
inline bool ItemBag::has_questsbag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ItemBag::set_has_questsbag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ItemBag::clear_has_questsbag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ItemBag::clear_questsbag() {
  questsbag_ = 0;
  clear_has_questsbag();
}
inline ::google::protobuf::int32 ItemBag::questsbag() const {
  // @@protoc_insertion_point(field_get:protocol.ItemBag.questsBag)
  return questsbag_;
}
inline void ItemBag::set_questsbag(::google::protobuf::int32 value) {
  set_has_questsbag();
  questsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.ItemBag.questsBag)
}

// -------------------------------------------------------------------

// EquipBaseInfo

// required int64 id = 1;
inline bool EquipBaseInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipBaseInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipBaseInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipBaseInfo::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::int64 EquipBaseInfo::id() const {
  // @@protoc_insertion_point(field_get:protocol.EquipBaseInfo.id)
  return id_;
}
inline void EquipBaseInfo::set_id(::google::protobuf::int64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protocol.EquipBaseInfo.id)
}

// required int64 uid = 2;
inline bool EquipBaseInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipBaseInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipBaseInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipBaseInfo::clear_uid() {
  uid_ = GOOGLE_LONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::int64 EquipBaseInfo::uid() const {
  // @@protoc_insertion_point(field_get:protocol.EquipBaseInfo.uid)
  return uid_;
}
inline void EquipBaseInfo::set_uid(::google::protobuf::int64 value) {
  set_has_uid();
  uid_ = value;
  // @@protoc_insertion_point(field_set:protocol.EquipBaseInfo.uid)
}

// -------------------------------------------------------------------

// EquipInfo

// required .protocol.EquipBaseInfo baseInfo = 1;
inline bool EquipInfo::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipInfo::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipInfo::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipInfo::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->Clear();
  clear_has_baseinfo();
}
inline const ::protocol::EquipBaseInfo& EquipInfo::baseinfo() const {
  const ::protocol::EquipBaseInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:protocol.EquipInfo.baseInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::EquipBaseInfo*>(
      &::protocol::_EquipBaseInfo_default_instance_);
}
inline ::protocol::EquipBaseInfo* EquipInfo::release_baseinfo() {
  // @@protoc_insertion_point(field_release:protocol.EquipInfo.baseInfo)
  clear_has_baseinfo();
  ::protocol::EquipBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline ::protocol::EquipBaseInfo* EquipInfo::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) {
    baseinfo_ = new ::protocol::EquipBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.EquipInfo.baseInfo)
  return baseinfo_;
}
inline void EquipInfo::set_allocated_baseinfo(::protocol::EquipBaseInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.EquipInfo.baseInfo)
}

// -------------------------------------------------------------------

// EquipChangeInfo

// required .protocol.EquipInfo info = 1;
inline bool EquipChangeInfo::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipChangeInfo::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipChangeInfo::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipChangeInfo::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::protocol::EquipInfo& EquipChangeInfo::info() const {
  const ::protocol::EquipInfo* p = info_;
  // @@protoc_insertion_point(field_get:protocol.EquipChangeInfo.info)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::EquipInfo*>(
      &::protocol::_EquipInfo_default_instance_);
}
inline ::protocol::EquipInfo* EquipChangeInfo::release_info() {
  // @@protoc_insertion_point(field_release:protocol.EquipChangeInfo.info)
  clear_has_info();
  ::protocol::EquipInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::protocol::EquipInfo* EquipChangeInfo::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    info_ = new ::protocol::EquipInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.EquipChangeInfo.info)
  return info_;
}
inline void EquipChangeInfo::set_allocated_info(::protocol::EquipInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:protocol.EquipChangeInfo.info)
}

// required int32 change = 2;
inline bool EquipChangeInfo::has_change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EquipChangeInfo::set_has_change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EquipChangeInfo::clear_has_change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EquipChangeInfo::clear_change() {
  change_ = 0;
  clear_has_change();
}
inline ::google::protobuf::int32 EquipChangeInfo::change() const {
  // @@protoc_insertion_point(field_get:protocol.EquipChangeInfo.change)
  return change_;
}
inline void EquipChangeInfo::set_change(::google::protobuf::int32 value) {
  set_has_change();
  change_ = value;
  // @@protoc_insertion_point(field_set:protocol.EquipChangeInfo.change)
}

// -------------------------------------------------------------------

// EquipBag

// repeated .protocol.EquipInfo infos = 1;
inline int EquipBag::infos_size() const {
  return infos_.size();
}
inline void EquipBag::clear_infos() {
  infos_.Clear();
}
inline const ::protocol::EquipInfo& EquipBag::infos(int index) const {
  // @@protoc_insertion_point(field_get:protocol.EquipBag.infos)
  return infos_.Get(index);
}
inline ::protocol::EquipInfo* EquipBag::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.EquipBag.infos)
  return infos_.Mutable(index);
}
inline ::protocol::EquipInfo* EquipBag::add_infos() {
  // @@protoc_insertion_point(field_add:protocol.EquipBag.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::EquipInfo >*
EquipBag::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:protocol.EquipBag.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::EquipInfo >&
EquipBag::infos() const {
  // @@protoc_insertion_point(field_list:protocol.EquipBag.infos)
  return infos_;
}

// required int32 bag = 2;
inline bool EquipBag::has_bag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipBag::set_has_bag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipBag::clear_has_bag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipBag::clear_bag() {
  bag_ = 0;
  clear_has_bag();
}
inline ::google::protobuf::int32 EquipBag::bag() const {
  // @@protoc_insertion_point(field_get:protocol.EquipBag.bag)
  return bag_;
}
inline void EquipBag::set_bag(::google::protobuf::int32 value) {
  set_has_bag();
  bag_ = value;
  // @@protoc_insertion_point(field_set:protocol.EquipBag.bag)
}

// -------------------------------------------------------------------

// RoleInfo

// required .protocol.RoleBaseInfo baseInfo = 1;
inline bool RoleInfo::has_baseinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoleInfo::set_has_baseinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoleInfo::clear_has_baseinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoleInfo::clear_baseinfo() {
  if (baseinfo_ != NULL) baseinfo_->Clear();
  clear_has_baseinfo();
}
inline const ::protocol::RoleBaseInfo& RoleInfo::baseinfo() const {
  const ::protocol::RoleBaseInfo* p = baseinfo_;
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.baseInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoleBaseInfo*>(
      &::protocol::_RoleBaseInfo_default_instance_);
}
inline ::protocol::RoleBaseInfo* RoleInfo::release_baseinfo() {
  // @@protoc_insertion_point(field_release:protocol.RoleInfo.baseInfo)
  clear_has_baseinfo();
  ::protocol::RoleBaseInfo* temp = baseinfo_;
  baseinfo_ = NULL;
  return temp;
}
inline ::protocol::RoleBaseInfo* RoleInfo::mutable_baseinfo() {
  set_has_baseinfo();
  if (baseinfo_ == NULL) {
    baseinfo_ = new ::protocol::RoleBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.RoleInfo.baseInfo)
  return baseinfo_;
}
inline void RoleInfo::set_allocated_baseinfo(::protocol::RoleBaseInfo* baseinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete baseinfo_;
  }
  if (baseinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      baseinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, baseinfo, submessage_arena);
    }
    set_has_baseinfo();
  } else {
    clear_has_baseinfo();
  }
  baseinfo_ = baseinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.RoleInfo.baseInfo)
}

// required int64 money = 2;
inline bool RoleInfo::has_money() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoleInfo::set_has_money() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoleInfo::clear_has_money() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoleInfo::clear_money() {
  money_ = GOOGLE_LONGLONG(0);
  clear_has_money();
}
inline ::google::protobuf::int64 RoleInfo::money() const {
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.money)
  return money_;
}
inline void RoleInfo::set_money(::google::protobuf::int64 value) {
  set_has_money();
  money_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleInfo.money)
}

// required int64 exp = 3;
inline bool RoleInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoleInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoleInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoleInfo::clear_exp() {
  exp_ = GOOGLE_LONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::int64 RoleInfo::exp() const {
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.exp)
  return exp_;
}
inline void RoleInfo::set_exp(::google::protobuf::int64 value) {
  set_has_exp();
  exp_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleInfo.exp)
}

// required .protocol.MapPos pos = 5;
inline bool RoleInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoleInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoleInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoleInfo::clear_pos() {
  if (pos_ != NULL) pos_->Clear();
  clear_has_pos();
}
inline const ::protocol::MapPos& RoleInfo::pos() const {
  const ::protocol::MapPos* p = pos_;
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.pos)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::MapPos*>(
      &::protocol::_MapPos_default_instance_);
}
inline ::protocol::MapPos* RoleInfo::release_pos() {
  // @@protoc_insertion_point(field_release:protocol.RoleInfo.pos)
  clear_has_pos();
  ::protocol::MapPos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline ::protocol::MapPos* RoleInfo::mutable_pos() {
  set_has_pos();
  if (pos_ == NULL) {
    pos_ = new ::protocol::MapPos;
  }
  // @@protoc_insertion_point(field_mutable:protocol.RoleInfo.pos)
  return pos_;
}
inline void RoleInfo::set_allocated_pos(::protocol::MapPos* pos) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pos_;
  }
  if (pos) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pos = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pos, submessage_arena);
    }
    set_has_pos();
  } else {
    clear_has_pos();
  }
  pos_ = pos;
  // @@protoc_insertion_point(field_set_allocated:protocol.RoleInfo.pos)
}

// optional int32 skillPoint = 6;
inline bool RoleInfo::has_skillpoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoleInfo::set_has_skillpoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoleInfo::clear_has_skillpoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoleInfo::clear_skillpoint() {
  skillpoint_ = 0;
  clear_has_skillpoint();
}
inline ::google::protobuf::int32 RoleInfo::skillpoint() const {
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.skillPoint)
  return skillpoint_;
}
inline void RoleInfo::set_skillpoint(::google::protobuf::int32 value) {
  set_has_skillpoint();
  skillpoint_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleInfo.skillPoint)
}

// optional int32 energy = 7;
inline bool RoleInfo::has_energy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoleInfo::set_has_energy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoleInfo::clear_has_energy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoleInfo::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline ::google::protobuf::int32 RoleInfo::energy() const {
  // @@protoc_insertion_point(field_get:protocol.RoleInfo.energy)
  return energy_;
}
inline void RoleInfo::set_energy(::google::protobuf::int32 value) {
  set_has_energy();
  energy_ = value;
  // @@protoc_insertion_point(field_set:protocol.RoleInfo.energy)
}

// -------------------------------------------------------------------

// LoginReqNet

// optional string channelId = 1;
inline bool LoginReqNet::has_channelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReqNet::set_has_channelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReqNet::clear_has_channelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReqNet::clear_channelid() {
  channelid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channelid();
}
inline const ::std::string& LoginReqNet::channelid() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.channelId)
  return channelid_.GetNoArena();
}
inline void LoginReqNet::set_channelid(const ::std::string& value) {
  set_has_channelid();
  channelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.channelId)
}
#if LANG_CXX11
inline void LoginReqNet::set_channelid(::std::string&& value) {
  set_has_channelid();
  channelid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginReqNet.channelId)
}
#endif
inline void LoginReqNet::set_channelid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channelid();
  channelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginReqNet.channelId)
}
inline void LoginReqNet::set_channelid(const char* value, size_t size) {
  set_has_channelid();
  channelid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginReqNet.channelId)
}
inline ::std::string* LoginReqNet::mutable_channelid() {
  set_has_channelid();
  // @@protoc_insertion_point(field_mutable:protocol.LoginReqNet.channelId)
  return channelid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReqNet::release_channelid() {
  // @@protoc_insertion_point(field_release:protocol.LoginReqNet.channelId)
  clear_has_channelid();
  return channelid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReqNet::set_allocated_channelid(::std::string* channelid) {
  if (channelid != NULL) {
    set_has_channelid();
  } else {
    clear_has_channelid();
  }
  channelid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channelid);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginReqNet.channelId)
}

// required string uid = 2;
inline bool LoginReqNet::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReqNet::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReqNet::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReqNet::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
inline const ::std::string& LoginReqNet::uid() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.uid)
  return uid_.GetNoArena();
}
inline void LoginReqNet::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.uid)
}
#if LANG_CXX11
inline void LoginReqNet::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginReqNet.uid)
}
#endif
inline void LoginReqNet::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginReqNet.uid)
}
inline void LoginReqNet::set_uid(const char* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginReqNet.uid)
}
inline ::std::string* LoginReqNet::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:protocol.LoginReqNet.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReqNet::release_uid() {
  // @@protoc_insertion_point(field_release:protocol.LoginReqNet.uid)
  clear_has_uid();
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReqNet::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginReqNet.uid)
}

// optional string sdkToken = 3;
inline bool LoginReqNet::has_sdktoken() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginReqNet::set_has_sdktoken() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginReqNet::clear_has_sdktoken() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginReqNet::clear_sdktoken() {
  sdktoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdktoken();
}
inline const ::std::string& LoginReqNet::sdktoken() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.sdkToken)
  return sdktoken_.GetNoArena();
}
inline void LoginReqNet::set_sdktoken(const ::std::string& value) {
  set_has_sdktoken();
  sdktoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.sdkToken)
}
#if LANG_CXX11
inline void LoginReqNet::set_sdktoken(::std::string&& value) {
  set_has_sdktoken();
  sdktoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginReqNet.sdkToken)
}
#endif
inline void LoginReqNet::set_sdktoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sdktoken();
  sdktoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginReqNet.sdkToken)
}
inline void LoginReqNet::set_sdktoken(const char* value, size_t size) {
  set_has_sdktoken();
  sdktoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginReqNet.sdkToken)
}
inline ::std::string* LoginReqNet::mutable_sdktoken() {
  set_has_sdktoken();
  // @@protoc_insertion_point(field_mutable:protocol.LoginReqNet.sdkToken)
  return sdktoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReqNet::release_sdktoken() {
  // @@protoc_insertion_point(field_release:protocol.LoginReqNet.sdkToken)
  clear_has_sdktoken();
  return sdktoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReqNet::set_allocated_sdktoken(::std::string* sdktoken) {
  if (sdktoken != NULL) {
    set_has_sdktoken();
  } else {
    clear_has_sdktoken();
  }
  sdktoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdktoken);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginReqNet.sdkToken)
}

// optional string sdkSession = 4;
inline bool LoginReqNet::has_sdksession() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginReqNet::set_has_sdksession() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginReqNet::clear_has_sdksession() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginReqNet::clear_sdksession() {
  sdksession_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sdksession();
}
inline const ::std::string& LoginReqNet::sdksession() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.sdkSession)
  return sdksession_.GetNoArena();
}
inline void LoginReqNet::set_sdksession(const ::std::string& value) {
  set_has_sdksession();
  sdksession_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.sdkSession)
}
#if LANG_CXX11
inline void LoginReqNet::set_sdksession(::std::string&& value) {
  set_has_sdksession();
  sdksession_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginReqNet.sdkSession)
}
#endif
inline void LoginReqNet::set_sdksession(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sdksession();
  sdksession_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginReqNet.sdkSession)
}
inline void LoginReqNet::set_sdksession(const char* value, size_t size) {
  set_has_sdksession();
  sdksession_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginReqNet.sdkSession)
}
inline ::std::string* LoginReqNet::mutable_sdksession() {
  set_has_sdksession();
  // @@protoc_insertion_point(field_mutable:protocol.LoginReqNet.sdkSession)
  return sdksession_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReqNet::release_sdksession() {
  // @@protoc_insertion_point(field_release:protocol.LoginReqNet.sdkSession)
  clear_has_sdksession();
  return sdksession_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReqNet::set_allocated_sdksession(::std::string* sdksession) {
  if (sdksession != NULL) {
    set_has_sdksession();
  } else {
    clear_has_sdksession();
  }
  sdksession_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sdksession);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginReqNet.sdkSession)
}

// required int32 loginType = 5;
inline bool LoginReqNet::has_logintype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoginReqNet::set_has_logintype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoginReqNet::clear_has_logintype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoginReqNet::clear_logintype() {
  logintype_ = 0;
  clear_has_logintype();
}
inline ::google::protobuf::int32 LoginReqNet::logintype() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.loginType)
  return logintype_;
}
inline void LoginReqNet::set_logintype(::google::protobuf::int32 value) {
  set_has_logintype();
  logintype_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.loginType)
}

// optional int32 version = 6;
inline bool LoginReqNet::has_version() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoginReqNet::set_has_version() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoginReqNet::clear_has_version() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoginReqNet::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 LoginReqNet::version() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.version)
  return version_;
}
inline void LoginReqNet::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.version)
}

// optional int32 runtime = 7;
inline bool LoginReqNet::has_runtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoginReqNet::set_has_runtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoginReqNet::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoginReqNet::clear_runtime() {
  runtime_ = 0;
  clear_has_runtime();
}
inline ::google::protobuf::int32 LoginReqNet::runtime() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.runtime)
  return runtime_;
}
inline void LoginReqNet::set_runtime(::google::protobuf::int32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.runtime)
}

// optional string deviceId = 8;
inline bool LoginReqNet::has_deviceid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginReqNet::set_has_deviceid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginReqNet::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginReqNet::clear_deviceid() {
  deviceid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_deviceid();
}
inline const ::std::string& LoginReqNet::deviceid() const {
  // @@protoc_insertion_point(field_get:protocol.LoginReqNet.deviceId)
  return deviceid_.GetNoArena();
}
inline void LoginReqNet::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginReqNet.deviceId)
}
#if LANG_CXX11
inline void LoginReqNet::set_deviceid(::std::string&& value) {
  set_has_deviceid();
  deviceid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginReqNet.deviceId)
}
#endif
inline void LoginReqNet::set_deviceid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginReqNet.deviceId)
}
inline void LoginReqNet::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  deviceid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginReqNet.deviceId)
}
inline ::std::string* LoginReqNet::mutable_deviceid() {
  set_has_deviceid();
  // @@protoc_insertion_point(field_mutable:protocol.LoginReqNet.deviceId)
  return deviceid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginReqNet::release_deviceid() {
  // @@protoc_insertion_point(field_release:protocol.LoginReqNet.deviceId)
  clear_has_deviceid();
  return deviceid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginReqNet::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid != NULL) {
    set_has_deviceid();
  } else {
    clear_has_deviceid();
  }
  deviceid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), deviceid);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginReqNet.deviceId)
}

// -------------------------------------------------------------------

// LoginRspNet

// required string account = 1;
inline bool LoginRspNet::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRspNet::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRspNet::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRspNet::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& LoginRspNet::account() const {
  // @@protoc_insertion_point(field_get:protocol.LoginRspNet.account)
  return account_.GetNoArena();
}
inline void LoginRspNet::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginRspNet.account)
}
#if LANG_CXX11
inline void LoginRspNet::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginRspNet.account)
}
#endif
inline void LoginRspNet::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginRspNet.account)
}
inline void LoginRspNet::set_account(const char* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginRspNet.account)
}
inline ::std::string* LoginRspNet::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:protocol.LoginRspNet.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginRspNet::release_account() {
  // @@protoc_insertion_point(field_release:protocol.LoginRspNet.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginRspNet::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginRspNet.account)
}

// required int32 ret = 2;
inline bool LoginRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 LoginRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.LoginRspNet.ret)
  return ret_;
}
inline void LoginRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginRspNet.ret)
}

// -------------------------------------------------------------------

// SelectGameServerReqNet

// required int32 gameServerId = 1;
inline bool SelectGameServerReqNet::has_gameserverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectGameServerReqNet::set_has_gameserverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectGameServerReqNet::clear_has_gameserverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectGameServerReqNet::clear_gameserverid() {
  gameserverid_ = 0;
  clear_has_gameserverid();
}
inline ::google::protobuf::int32 SelectGameServerReqNet::gameserverid() const {
  // @@protoc_insertion_point(field_get:protocol.SelectGameServerReqNet.gameServerId)
  return gameserverid_;
}
inline void SelectGameServerReqNet::set_gameserverid(::google::protobuf::int32 value) {
  set_has_gameserverid();
  gameserverid_ = value;
  // @@protoc_insertion_point(field_set:protocol.SelectGameServerReqNet.gameServerId)
}

// -------------------------------------------------------------------

// SelectGameServerRspNet

// required .protocol.ServerInfo server = 1;
inline bool SelectGameServerRspNet::has_server() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SelectGameServerRspNet::set_has_server() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SelectGameServerRspNet::clear_has_server() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SelectGameServerRspNet::clear_server() {
  if (server_ != NULL) server_->Clear();
  clear_has_server();
}
inline const ::protocol::ServerInfo& SelectGameServerRspNet::server() const {
  const ::protocol::ServerInfo* p = server_;
  // @@protoc_insertion_point(field_get:protocol.SelectGameServerRspNet.server)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ServerInfo*>(
      &::protocol::_ServerInfo_default_instance_);
}
inline ::protocol::ServerInfo* SelectGameServerRspNet::release_server() {
  // @@protoc_insertion_point(field_release:protocol.SelectGameServerRspNet.server)
  clear_has_server();
  ::protocol::ServerInfo* temp = server_;
  server_ = NULL;
  return temp;
}
inline ::protocol::ServerInfo* SelectGameServerRspNet::mutable_server() {
  set_has_server();
  if (server_ == NULL) {
    server_ = new ::protocol::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.SelectGameServerRspNet.server)
  return server_;
}
inline void SelectGameServerRspNet::set_allocated_server(::protocol::ServerInfo* server) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_;
  }
  if (server) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    set_has_server();
  } else {
    clear_has_server();
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:protocol.SelectGameServerRspNet.server)
}

// optional .protocol.ServerInfo udpserver = 2;
inline bool SelectGameServerRspNet::has_udpserver() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SelectGameServerRspNet::set_has_udpserver() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SelectGameServerRspNet::clear_has_udpserver() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SelectGameServerRspNet::clear_udpserver() {
  if (udpserver_ != NULL) udpserver_->Clear();
  clear_has_udpserver();
}
inline const ::protocol::ServerInfo& SelectGameServerRspNet::udpserver() const {
  const ::protocol::ServerInfo* p = udpserver_;
  // @@protoc_insertion_point(field_get:protocol.SelectGameServerRspNet.udpserver)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ServerInfo*>(
      &::protocol::_ServerInfo_default_instance_);
}
inline ::protocol::ServerInfo* SelectGameServerRspNet::release_udpserver() {
  // @@protoc_insertion_point(field_release:protocol.SelectGameServerRspNet.udpserver)
  clear_has_udpserver();
  ::protocol::ServerInfo* temp = udpserver_;
  udpserver_ = NULL;
  return temp;
}
inline ::protocol::ServerInfo* SelectGameServerRspNet::mutable_udpserver() {
  set_has_udpserver();
  if (udpserver_ == NULL) {
    udpserver_ = new ::protocol::ServerInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.SelectGameServerRspNet.udpserver)
  return udpserver_;
}
inline void SelectGameServerRspNet::set_allocated_udpserver(::protocol::ServerInfo* udpserver) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete udpserver_;
  }
  if (udpserver) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      udpserver = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, udpserver, submessage_arena);
    }
    set_has_udpserver();
  } else {
    clear_has_udpserver();
  }
  udpserver_ = udpserver;
  // @@protoc_insertion_point(field_set_allocated:protocol.SelectGameServerRspNet.udpserver)
}

// required string gameToken = 3;
inline bool SelectGameServerRspNet::has_gametoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SelectGameServerRspNet::set_has_gametoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SelectGameServerRspNet::clear_has_gametoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SelectGameServerRspNet::clear_gametoken() {
  gametoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gametoken();
}
inline const ::std::string& SelectGameServerRspNet::gametoken() const {
  // @@protoc_insertion_point(field_get:protocol.SelectGameServerRspNet.gameToken)
  return gametoken_.GetNoArena();
}
inline void SelectGameServerRspNet::set_gametoken(const ::std::string& value) {
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.SelectGameServerRspNet.gameToken)
}
#if LANG_CXX11
inline void SelectGameServerRspNet::set_gametoken(::std::string&& value) {
  set_has_gametoken();
  gametoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.SelectGameServerRspNet.gameToken)
}
#endif
inline void SelectGameServerRspNet::set_gametoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.SelectGameServerRspNet.gameToken)
}
inline void SelectGameServerRspNet::set_gametoken(const char* value, size_t size) {
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.SelectGameServerRspNet.gameToken)
}
inline ::std::string* SelectGameServerRspNet::mutable_gametoken() {
  set_has_gametoken();
  // @@protoc_insertion_point(field_mutable:protocol.SelectGameServerRspNet.gameToken)
  return gametoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectGameServerRspNet::release_gametoken() {
  // @@protoc_insertion_point(field_release:protocol.SelectGameServerRspNet.gameToken)
  clear_has_gametoken();
  return gametoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectGameServerRspNet::set_allocated_gametoken(::std::string* gametoken) {
  if (gametoken != NULL) {
    set_has_gametoken();
  } else {
    clear_has_gametoken();
  }
  gametoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gametoken);
  // @@protoc_insertion_point(field_set_allocated:protocol.SelectGameServerRspNet.gameToken)
}

// required int32 ret = 4;
inline bool SelectGameServerRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SelectGameServerRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SelectGameServerRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SelectGameServerRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 SelectGameServerRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.SelectGameServerRspNet.ret)
  return ret_;
}
inline void SelectGameServerRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.SelectGameServerRspNet.ret)
}

// -------------------------------------------------------------------

// LoginGameReqNet

// required string gameToken = 1;
inline bool LoginGameReqNet::has_gametoken() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGameReqNet::set_has_gametoken() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGameReqNet::clear_has_gametoken() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGameReqNet::clear_gametoken() {
  gametoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gametoken();
}
inline const ::std::string& LoginGameReqNet::gametoken() const {
  // @@protoc_insertion_point(field_get:protocol.LoginGameReqNet.gameToken)
  return gametoken_.GetNoArena();
}
inline void LoginGameReqNet::set_gametoken(const ::std::string& value) {
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginGameReqNet.gameToken)
}
#if LANG_CXX11
inline void LoginGameReqNet::set_gametoken(::std::string&& value) {
  set_has_gametoken();
  gametoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginGameReqNet.gameToken)
}
#endif
inline void LoginGameReqNet::set_gametoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginGameReqNet.gameToken)
}
inline void LoginGameReqNet::set_gametoken(const char* value, size_t size) {
  set_has_gametoken();
  gametoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginGameReqNet.gameToken)
}
inline ::std::string* LoginGameReqNet::mutable_gametoken() {
  set_has_gametoken();
  // @@protoc_insertion_point(field_mutable:protocol.LoginGameReqNet.gameToken)
  return gametoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginGameReqNet::release_gametoken() {
  // @@protoc_insertion_point(field_release:protocol.LoginGameReqNet.gameToken)
  clear_has_gametoken();
  return gametoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginGameReqNet::set_allocated_gametoken(::std::string* gametoken) {
  if (gametoken != NULL) {
    set_has_gametoken();
  } else {
    clear_has_gametoken();
  }
  gametoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gametoken);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginGameReqNet.gameToken)
}

// required string account = 2;
inline bool LoginGameReqNet::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginGameReqNet::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginGameReqNet::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginGameReqNet::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_account();
}
inline const ::std::string& LoginGameReqNet::account() const {
  // @@protoc_insertion_point(field_get:protocol.LoginGameReqNet.account)
  return account_.GetNoArena();
}
inline void LoginGameReqNet::set_account(const ::std::string& value) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.LoginGameReqNet.account)
}
#if LANG_CXX11
inline void LoginGameReqNet::set_account(::std::string&& value) {
  set_has_account();
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.LoginGameReqNet.account)
}
#endif
inline void LoginGameReqNet::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.LoginGameReqNet.account)
}
inline void LoginGameReqNet::set_account(const char* value, size_t size) {
  set_has_account();
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.LoginGameReqNet.account)
}
inline ::std::string* LoginGameReqNet::mutable_account() {
  set_has_account();
  // @@protoc_insertion_point(field_mutable:protocol.LoginGameReqNet.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LoginGameReqNet::release_account() {
  // @@protoc_insertion_point(field_release:protocol.LoginGameReqNet.account)
  clear_has_account();
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LoginGameReqNet::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    set_has_account();
  } else {
    clear_has_account();
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginGameReqNet.account)
}

// -------------------------------------------------------------------

// LoginGameRspNet

// required int32 ret = 1;
inline bool LoginGameRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginGameRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginGameRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginGameRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 LoginGameRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.LoginGameRspNet.ret)
  return ret_;
}
inline void LoginGameRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginGameRspNet.ret)
}

// optional .protocol.PlayerBaseInfo player = 2;
inline bool LoginGameRspNet::has_player() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGameRspNet::set_has_player() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGameRspNet::clear_has_player() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGameRspNet::clear_player() {
  if (player_ != NULL) player_->Clear();
  clear_has_player();
}
inline const ::protocol::PlayerBaseInfo& LoginGameRspNet::player() const {
  const ::protocol::PlayerBaseInfo* p = player_;
  // @@protoc_insertion_point(field_get:protocol.LoginGameRspNet.player)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::PlayerBaseInfo*>(
      &::protocol::_PlayerBaseInfo_default_instance_);
}
inline ::protocol::PlayerBaseInfo* LoginGameRspNet::release_player() {
  // @@protoc_insertion_point(field_release:protocol.LoginGameRspNet.player)
  clear_has_player();
  ::protocol::PlayerBaseInfo* temp = player_;
  player_ = NULL;
  return temp;
}
inline ::protocol::PlayerBaseInfo* LoginGameRspNet::mutable_player() {
  set_has_player();
  if (player_ == NULL) {
    player_ = new ::protocol::PlayerBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.LoginGameRspNet.player)
  return player_;
}
inline void LoginGameRspNet::set_allocated_player(::protocol::PlayerBaseInfo* player) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete player_;
  }
  if (player) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      player = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, player, submessage_arena);
    }
    set_has_player();
  } else {
    clear_has_player();
  }
  player_ = player;
  // @@protoc_insertion_point(field_set_allocated:protocol.LoginGameRspNet.player)
}

// repeated .protocol.RoleBaseInfo roles = 3;
inline int LoginGameRspNet::roles_size() const {
  return roles_.size();
}
inline void LoginGameRspNet::clear_roles() {
  roles_.Clear();
}
inline const ::protocol::RoleBaseInfo& LoginGameRspNet::roles(int index) const {
  // @@protoc_insertion_point(field_get:protocol.LoginGameRspNet.roles)
  return roles_.Get(index);
}
inline ::protocol::RoleBaseInfo* LoginGameRspNet::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.LoginGameRspNet.roles)
  return roles_.Mutable(index);
}
inline ::protocol::RoleBaseInfo* LoginGameRspNet::add_roles() {
  // @@protoc_insertion_point(field_add:protocol.LoginGameRspNet.roles)
  return roles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::RoleBaseInfo >*
LoginGameRspNet::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:protocol.LoginGameRspNet.roles)
  return &roles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::RoleBaseInfo >&
LoginGameRspNet::roles() const {
  // @@protoc_insertion_point(field_list:protocol.LoginGameRspNet.roles)
  return roles_;
}

// required int32 soltCount = 4;
inline bool LoginGameRspNet::has_soltcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginGameRspNet::set_has_soltcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginGameRspNet::clear_has_soltcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginGameRspNet::clear_soltcount() {
  soltcount_ = 0;
  clear_has_soltcount();
}
inline ::google::protobuf::int32 LoginGameRspNet::soltcount() const {
  // @@protoc_insertion_point(field_get:protocol.LoginGameRspNet.soltCount)
  return soltcount_;
}
inline void LoginGameRspNet::set_soltcount(::google::protobuf::int32 value) {
  set_has_soltcount();
  soltcount_ = value;
  // @@protoc_insertion_point(field_set:protocol.LoginGameRspNet.soltCount)
}

// -------------------------------------------------------------------

// CreateRoleReqNet

// required string name = 1;
inline bool CreateRoleReqNet::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleReqNet::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleReqNet::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleReqNet::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CreateRoleReqNet::name() const {
  // @@protoc_insertion_point(field_get:protocol.CreateRoleReqNet.name)
  return name_.GetNoArena();
}
inline void CreateRoleReqNet::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.CreateRoleReqNet.name)
}
#if LANG_CXX11
inline void CreateRoleReqNet::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.CreateRoleReqNet.name)
}
#endif
inline void CreateRoleReqNet::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.CreateRoleReqNet.name)
}
inline void CreateRoleReqNet::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.CreateRoleReqNet.name)
}
inline ::std::string* CreateRoleReqNet::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:protocol.CreateRoleReqNet.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRoleReqNet::release_name() {
  // @@protoc_insertion_point(field_release:protocol.CreateRoleReqNet.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRoleReqNet::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateRoleReqNet.name)
}

// required int32 jobId = 2;
inline bool CreateRoleReqNet::has_jobid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleReqNet::set_has_jobid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleReqNet::clear_has_jobid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleReqNet::clear_jobid() {
  jobid_ = 0;
  clear_has_jobid();
}
inline ::google::protobuf::int32 CreateRoleReqNet::jobid() const {
  // @@protoc_insertion_point(field_get:protocol.CreateRoleReqNet.jobId)
  return jobid_;
}
inline void CreateRoleReqNet::set_jobid(::google::protobuf::int32 value) {
  set_has_jobid();
  jobid_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateRoleReqNet.jobId)
}

// required int32 sex = 3;
inline bool CreateRoleReqNet::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRoleReqNet::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRoleReqNet::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRoleReqNet::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 CreateRoleReqNet::sex() const {
  // @@protoc_insertion_point(field_get:protocol.CreateRoleReqNet.sex)
  return sex_;
}
inline void CreateRoleReqNet::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateRoleReqNet.sex)
}

// -------------------------------------------------------------------

// CreateRoleRspNet

// required int32 ret = 1;
inline bool CreateRoleRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRoleRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRoleRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRoleRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 CreateRoleRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.CreateRoleRspNet.ret)
  return ret_;
}
inline void CreateRoleRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateRoleRspNet.ret)
}

// required .protocol.RoleBaseInfo role = 2;
inline bool CreateRoleRspNet::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRoleRspNet::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRoleRspNet::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRoleRspNet::clear_role() {
  if (role_ != NULL) role_->Clear();
  clear_has_role();
}
inline const ::protocol::RoleBaseInfo& CreateRoleRspNet::role() const {
  const ::protocol::RoleBaseInfo* p = role_;
  // @@protoc_insertion_point(field_get:protocol.CreateRoleRspNet.role)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoleBaseInfo*>(
      &::protocol::_RoleBaseInfo_default_instance_);
}
inline ::protocol::RoleBaseInfo* CreateRoleRspNet::release_role() {
  // @@protoc_insertion_point(field_release:protocol.CreateRoleRspNet.role)
  clear_has_role();
  ::protocol::RoleBaseInfo* temp = role_;
  role_ = NULL;
  return temp;
}
inline ::protocol::RoleBaseInfo* CreateRoleRspNet::mutable_role() {
  set_has_role();
  if (role_ == NULL) {
    role_ = new ::protocol::RoleBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.CreateRoleRspNet.role)
  return role_;
}
inline void CreateRoleRspNet::set_allocated_role(::protocol::RoleBaseInfo* role) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete role_;
  }
  if (role) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      role = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, role, submessage_arena);
    }
    set_has_role();
  } else {
    clear_has_role();
  }
  role_ = role;
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateRoleRspNet.role)
}

// -------------------------------------------------------------------

// EnterSceneReqNet

// required int64 roleId = 1;
inline bool EnterSceneReqNet::has_roleid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneReqNet::set_has_roleid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneReqNet::clear_has_roleid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneReqNet::clear_roleid() {
  roleid_ = GOOGLE_LONGLONG(0);
  clear_has_roleid();
}
inline ::google::protobuf::int64 EnterSceneReqNet::roleid() const {
  // @@protoc_insertion_point(field_get:protocol.EnterSceneReqNet.roleId)
  return roleid_;
}
inline void EnterSceneReqNet::set_roleid(::google::protobuf::int64 value) {
  set_has_roleid();
  roleid_ = value;
  // @@protoc_insertion_point(field_set:protocol.EnterSceneReqNet.roleId)
}

// -------------------------------------------------------------------

// EnterSceneRspNet

// required int32 ret = 1;
inline bool EnterSceneRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnterSceneRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnterSceneRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnterSceneRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 EnterSceneRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.EnterSceneRspNet.ret)
  return ret_;
}
inline void EnterSceneRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.EnterSceneRspNet.ret)
}

// optional .protocol.RoleInfo roleInfo = 2;
inline bool EnterSceneRspNet::has_roleinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnterSceneRspNet::set_has_roleinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnterSceneRspNet::clear_has_roleinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnterSceneRspNet::clear_roleinfo() {
  if (roleinfo_ != NULL) roleinfo_->Clear();
  clear_has_roleinfo();
}
inline const ::protocol::RoleInfo& EnterSceneRspNet::roleinfo() const {
  const ::protocol::RoleInfo* p = roleinfo_;
  // @@protoc_insertion_point(field_get:protocol.EnterSceneRspNet.roleInfo)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::RoleInfo*>(
      &::protocol::_RoleInfo_default_instance_);
}
inline ::protocol::RoleInfo* EnterSceneRspNet::release_roleinfo() {
  // @@protoc_insertion_point(field_release:protocol.EnterSceneRspNet.roleInfo)
  clear_has_roleinfo();
  ::protocol::RoleInfo* temp = roleinfo_;
  roleinfo_ = NULL;
  return temp;
}
inline ::protocol::RoleInfo* EnterSceneRspNet::mutable_roleinfo() {
  set_has_roleinfo();
  if (roleinfo_ == NULL) {
    roleinfo_ = new ::protocol::RoleInfo;
  }
  // @@protoc_insertion_point(field_mutable:protocol.EnterSceneRspNet.roleInfo)
  return roleinfo_;
}
inline void EnterSceneRspNet::set_allocated_roleinfo(::protocol::RoleInfo* roleinfo) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roleinfo_;
  }
  if (roleinfo) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roleinfo = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roleinfo, submessage_arena);
    }
    set_has_roleinfo();
  } else {
    clear_has_roleinfo();
  }
  roleinfo_ = roleinfo;
  // @@protoc_insertion_point(field_set_allocated:protocol.EnterSceneRspNet.roleInfo)
}

// -------------------------------------------------------------------

// BagNotifyNet

// required .protocol.ItemBag bag = 1;
inline bool BagNotifyNet::has_bag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BagNotifyNet::set_has_bag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BagNotifyNet::clear_has_bag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BagNotifyNet::clear_bag() {
  if (bag_ != NULL) bag_->Clear();
  clear_has_bag();
}
inline const ::protocol::ItemBag& BagNotifyNet::bag() const {
  const ::protocol::ItemBag* p = bag_;
  // @@protoc_insertion_point(field_get:protocol.BagNotifyNet.bag)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::ItemBag*>(
      &::protocol::_ItemBag_default_instance_);
}
inline ::protocol::ItemBag* BagNotifyNet::release_bag() {
  // @@protoc_insertion_point(field_release:protocol.BagNotifyNet.bag)
  clear_has_bag();
  ::protocol::ItemBag* temp = bag_;
  bag_ = NULL;
  return temp;
}
inline ::protocol::ItemBag* BagNotifyNet::mutable_bag() {
  set_has_bag();
  if (bag_ == NULL) {
    bag_ = new ::protocol::ItemBag;
  }
  // @@protoc_insertion_point(field_mutable:protocol.BagNotifyNet.bag)
  return bag_;
}
inline void BagNotifyNet::set_allocated_bag(::protocol::ItemBag* bag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bag_;
  }
  if (bag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bag, submessage_arena);
    }
    set_has_bag();
  } else {
    clear_has_bag();
  }
  bag_ = bag;
  // @@protoc_insertion_point(field_set_allocated:protocol.BagNotifyNet.bag)
}

// -------------------------------------------------------------------

// EquipBagNotifyNet

// required .protocol.EquipBag bag = 1;
inline bool EquipBagNotifyNet::has_bag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EquipBagNotifyNet::set_has_bag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EquipBagNotifyNet::clear_has_bag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EquipBagNotifyNet::clear_bag() {
  if (bag_ != NULL) bag_->Clear();
  clear_has_bag();
}
inline const ::protocol::EquipBag& EquipBagNotifyNet::bag() const {
  const ::protocol::EquipBag* p = bag_;
  // @@protoc_insertion_point(field_get:protocol.EquipBagNotifyNet.bag)
  return p != NULL ? *p : *reinterpret_cast<const ::protocol::EquipBag*>(
      &::protocol::_EquipBag_default_instance_);
}
inline ::protocol::EquipBag* EquipBagNotifyNet::release_bag() {
  // @@protoc_insertion_point(field_release:protocol.EquipBagNotifyNet.bag)
  clear_has_bag();
  ::protocol::EquipBag* temp = bag_;
  bag_ = NULL;
  return temp;
}
inline ::protocol::EquipBag* EquipBagNotifyNet::mutable_bag() {
  set_has_bag();
  if (bag_ == NULL) {
    bag_ = new ::protocol::EquipBag;
  }
  // @@protoc_insertion_point(field_mutable:protocol.EquipBagNotifyNet.bag)
  return bag_;
}
inline void EquipBagNotifyNet::set_allocated_bag(::protocol::EquipBag* bag) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bag_;
  }
  if (bag) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bag = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bag, submessage_arena);
    }
    set_has_bag();
  } else {
    clear_has_bag();
  }
  bag_ = bag;
  // @@protoc_insertion_point(field_set_allocated:protocol.EquipBagNotifyNet.bag)
}

// -------------------------------------------------------------------

// ErrorNotifyNet

// required int32 err = 1;
inline bool ErrorNotifyNet::has_err() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ErrorNotifyNet::set_has_err() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ErrorNotifyNet::clear_has_err() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ErrorNotifyNet::clear_err() {
  err_ = 0;
  clear_has_err();
}
inline ::google::protobuf::int32 ErrorNotifyNet::err() const {
  // @@protoc_insertion_point(field_get:protocol.ErrorNotifyNet.err)
  return err_;
}
inline void ErrorNotifyNet::set_err(::google::protobuf::int32 value) {
  set_has_err();
  err_ = value;
  // @@protoc_insertion_point(field_set:protocol.ErrorNotifyNet.err)
}

// -------------------------------------------------------------------

// UpdLoginReqNet

// required int32 id = 1;
inline bool UpdLoginReqNet::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdLoginReqNet::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdLoginReqNet::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdLoginReqNet::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UpdLoginReqNet::id() const {
  // @@protoc_insertion_point(field_get:protocol.UpdLoginReqNet.id)
  return id_;
}
inline void UpdLoginReqNet::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdLoginReqNet.id)
}

// required int64 playerId = 2;
inline bool UpdLoginReqNet::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdLoginReqNet::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdLoginReqNet::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdLoginReqNet::clear_playerid() {
  playerid_ = GOOGLE_LONGLONG(0);
  clear_has_playerid();
}
inline ::google::protobuf::int64 UpdLoginReqNet::playerid() const {
  // @@protoc_insertion_point(field_get:protocol.UpdLoginReqNet.playerId)
  return playerid_;
}
inline void UpdLoginReqNet::set_playerid(::google::protobuf::int64 value) {
  set_has_playerid();
  playerid_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdLoginReqNet.playerId)
}

// -------------------------------------------------------------------

// UpdLoginRspNet

// required int32 kcpId = 1;
inline bool UpdLoginRspNet::has_kcpid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdLoginRspNet::set_has_kcpid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdLoginRspNet::clear_has_kcpid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdLoginRspNet::clear_kcpid() {
  kcpid_ = 0;
  clear_has_kcpid();
}
inline ::google::protobuf::int32 UpdLoginRspNet::kcpid() const {
  // @@protoc_insertion_point(field_get:protocol.UpdLoginRspNet.kcpId)
  return kcpid_;
}
inline void UpdLoginRspNet::set_kcpid(::google::protobuf::int32 value) {
  set_has_kcpid();
  kcpid_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdLoginRspNet.kcpId)
}

// required int32 id = 2;
inline bool UpdLoginRspNet::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdLoginRspNet::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdLoginRspNet::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdLoginRspNet::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 UpdLoginRspNet::id() const {
  // @@protoc_insertion_point(field_get:protocol.UpdLoginRspNet.id)
  return id_;
}
inline void UpdLoginRspNet::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdLoginRspNet.id)
}

// -------------------------------------------------------------------

// UpdTestReqNet

// required int32 dataId = 1;
inline bool UpdTestReqNet::has_dataid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdTestReqNet::set_has_dataid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdTestReqNet::clear_has_dataid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdTestReqNet::clear_dataid() {
  dataid_ = 0;
  clear_has_dataid();
}
inline ::google::protobuf::int32 UpdTestReqNet::dataid() const {
  // @@protoc_insertion_point(field_get:protocol.UpdTestReqNet.dataId)
  return dataid_;
}
inline void UpdTestReqNet::set_dataid(::google::protobuf::int32 value) {
  set_has_dataid();
  dataid_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdTestReqNet.dataId)
}

// -------------------------------------------------------------------

// UpdTestRspNet

// required int32 dataId = 1;
inline bool UpdTestRspNet::has_dataid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdTestRspNet::set_has_dataid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdTestRspNet::clear_has_dataid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdTestRspNet::clear_dataid() {
  dataid_ = 0;
  clear_has_dataid();
}
inline ::google::protobuf::int32 UpdTestRspNet::dataid() const {
  // @@protoc_insertion_point(field_get:protocol.UpdTestRspNet.dataId)
  return dataid_;
}
inline void UpdTestRspNet::set_dataid(::google::protobuf::int32 value) {
  set_has_dataid();
  dataid_ = value;
  // @@protoc_insertion_point(field_set:protocol.UpdTestRspNet.dataId)
}

// -------------------------------------------------------------------

// BuyRoleSoltReqNet

// -------------------------------------------------------------------

// BuyRoleSoltRspNet

// required int32 soltCount = 1;
inline bool BuyRoleSoltRspNet::has_soltcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyRoleSoltRspNet::set_has_soltcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyRoleSoltRspNet::clear_has_soltcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyRoleSoltRspNet::clear_soltcount() {
  soltcount_ = 0;
  clear_has_soltcount();
}
inline ::google::protobuf::int32 BuyRoleSoltRspNet::soltcount() const {
  // @@protoc_insertion_point(field_get:protocol.BuyRoleSoltRspNet.soltCount)
  return soltcount_;
}
inline void BuyRoleSoltRspNet::set_soltcount(::google::protobuf::int32 value) {
  set_has_soltcount();
  soltcount_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyRoleSoltRspNet.soltCount)
}

// required int32 ret = 2;
inline bool BuyRoleSoltRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyRoleSoltRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyRoleSoltRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyRoleSoltRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 BuyRoleSoltRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.BuyRoleSoltRspNet.ret)
  return ret_;
}
inline void BuyRoleSoltRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyRoleSoltRspNet.ret)
}

// -------------------------------------------------------------------

// GMCMDReqNet

// required string cmd = 1;
inline bool GMCMDReqNet::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMCMDReqNet::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMCMDReqNet::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMCMDReqNet::clear_cmd() {
  cmd_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cmd();
}
inline const ::std::string& GMCMDReqNet::cmd() const {
  // @@protoc_insertion_point(field_get:protocol.GMCMDReqNet.cmd)
  return cmd_.GetNoArena();
}
inline void GMCMDReqNet::set_cmd(const ::std::string& value) {
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.GMCMDReqNet.cmd)
}
#if LANG_CXX11
inline void GMCMDReqNet::set_cmd(::std::string&& value) {
  set_has_cmd();
  cmd_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.GMCMDReqNet.cmd)
}
#endif
inline void GMCMDReqNet::set_cmd(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.GMCMDReqNet.cmd)
}
inline void GMCMDReqNet::set_cmd(const char* value, size_t size) {
  set_has_cmd();
  cmd_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.GMCMDReqNet.cmd)
}
inline ::std::string* GMCMDReqNet::mutable_cmd() {
  set_has_cmd();
  // @@protoc_insertion_point(field_mutable:protocol.GMCMDReqNet.cmd)
  return cmd_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GMCMDReqNet::release_cmd() {
  // @@protoc_insertion_point(field_release:protocol.GMCMDReqNet.cmd)
  clear_has_cmd();
  return cmd_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GMCMDReqNet::set_allocated_cmd(::std::string* cmd) {
  if (cmd != NULL) {
    set_has_cmd();
  } else {
    clear_has_cmd();
  }
  cmd_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cmd);
  // @@protoc_insertion_point(field_set_allocated:protocol.GMCMDReqNet.cmd)
}

// -------------------------------------------------------------------

// GMCMDRspNet

// required string ret = 1;
inline bool GMCMDRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GMCMDRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GMCMDRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GMCMDRspNet::clear_ret() {
  ret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ret();
}
inline const ::std::string& GMCMDRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.GMCMDRspNet.ret)
  return ret_.GetNoArena();
}
inline void GMCMDRspNet::set_ret(const ::std::string& value) {
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:protocol.GMCMDRspNet.ret)
}
#if LANG_CXX11
inline void GMCMDRspNet::set_ret(::std::string&& value) {
  set_has_ret();
  ret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:protocol.GMCMDRspNet.ret)
}
#endif
inline void GMCMDRspNet::set_ret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:protocol.GMCMDRspNet.ret)
}
inline void GMCMDRspNet::set_ret(const char* value, size_t size) {
  set_has_ret();
  ret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:protocol.GMCMDRspNet.ret)
}
inline ::std::string* GMCMDRspNet::mutable_ret() {
  set_has_ret();
  // @@protoc_insertion_point(field_mutable:protocol.GMCMDRspNet.ret)
  return ret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GMCMDRspNet::release_ret() {
  // @@protoc_insertion_point(field_release:protocol.GMCMDRspNet.ret)
  clear_has_ret();
  return ret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GMCMDRspNet::set_allocated_ret(::std::string* ret) {
  if (ret != NULL) {
    set_has_ret();
  } else {
    clear_has_ret();
  }
  ret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ret);
  // @@protoc_insertion_point(field_set_allocated:protocol.GMCMDRspNet.ret)
}

// -------------------------------------------------------------------

// ItemChangeNotifyNet

// repeated .protocol.ItemChangeInfo infos = 1;
inline int ItemChangeNotifyNet::infos_size() const {
  return infos_.size();
}
inline void ItemChangeNotifyNet::clear_infos() {
  infos_.Clear();
}
inline const ::protocol::ItemChangeInfo& ItemChangeNotifyNet::infos(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ItemChangeNotifyNet.infos)
  return infos_.Get(index);
}
inline ::protocol::ItemChangeInfo* ItemChangeNotifyNet::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ItemChangeNotifyNet.infos)
  return infos_.Mutable(index);
}
inline ::protocol::ItemChangeInfo* ItemChangeNotifyNet::add_infos() {
  // @@protoc_insertion_point(field_add:protocol.ItemChangeNotifyNet.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ItemChangeInfo >*
ItemChangeNotifyNet::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ItemChangeNotifyNet.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ItemChangeInfo >&
ItemChangeNotifyNet::infos() const {
  // @@protoc_insertion_point(field_list:protocol.ItemChangeNotifyNet.infos)
  return infos_;
}

// -------------------------------------------------------------------

// EquipChangeNotifyNet

// repeated .protocol.EquipChangeInfo infos = 1;
inline int EquipChangeNotifyNet::infos_size() const {
  return infos_.size();
}
inline void EquipChangeNotifyNet::clear_infos() {
  infos_.Clear();
}
inline const ::protocol::EquipChangeInfo& EquipChangeNotifyNet::infos(int index) const {
  // @@protoc_insertion_point(field_get:protocol.EquipChangeNotifyNet.infos)
  return infos_.Get(index);
}
inline ::protocol::EquipChangeInfo* EquipChangeNotifyNet::mutable_infos(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.EquipChangeNotifyNet.infos)
  return infos_.Mutable(index);
}
inline ::protocol::EquipChangeInfo* EquipChangeNotifyNet::add_infos() {
  // @@protoc_insertion_point(field_add:protocol.EquipChangeNotifyNet.infos)
  return infos_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::EquipChangeInfo >*
EquipChangeNotifyNet::mutable_infos() {
  // @@protoc_insertion_point(field_mutable_list:protocol.EquipChangeNotifyNet.infos)
  return &infos_;
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::EquipChangeInfo >&
EquipChangeNotifyNet::infos() const {
  // @@protoc_insertion_point(field_list:protocol.EquipChangeNotifyNet.infos)
  return infos_;
}

// -------------------------------------------------------------------

// BuyBagSoltReqNet

// -------------------------------------------------------------------

// BuyBagSoltRspNet

// required int32 ret = 1;
inline bool BuyBagSoltRspNet::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BuyBagSoltRspNet::set_has_ret() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BuyBagSoltRspNet::clear_has_ret() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BuyBagSoltRspNet::clear_ret() {
  ret_ = 0;
  clear_has_ret();
}
inline ::google::protobuf::int32 BuyBagSoltRspNet::ret() const {
  // @@protoc_insertion_point(field_get:protocol.BuyBagSoltRspNet.ret)
  return ret_;
}
inline void BuyBagSoltRspNet::set_ret(::google::protobuf::int32 value) {
  set_has_ret();
  ret_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyBagSoltRspNet.ret)
}

// required int32 consumptionsBag = 2;
inline bool BuyBagSoltRspNet::has_consumptionsbag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BuyBagSoltRspNet::set_has_consumptionsbag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BuyBagSoltRspNet::clear_has_consumptionsbag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BuyBagSoltRspNet::clear_consumptionsbag() {
  consumptionsbag_ = 0;
  clear_has_consumptionsbag();
}
inline ::google::protobuf::int32 BuyBagSoltRspNet::consumptionsbag() const {
  // @@protoc_insertion_point(field_get:protocol.BuyBagSoltRspNet.consumptionsBag)
  return consumptionsbag_;
}
inline void BuyBagSoltRspNet::set_consumptionsbag(::google::protobuf::int32 value) {
  set_has_consumptionsbag();
  consumptionsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyBagSoltRspNet.consumptionsBag)
}

// required int32 materialsBag = 3;
inline bool BuyBagSoltRspNet::has_materialsbag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BuyBagSoltRspNet::set_has_materialsbag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BuyBagSoltRspNet::clear_has_materialsbag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BuyBagSoltRspNet::clear_materialsbag() {
  materialsbag_ = 0;
  clear_has_materialsbag();
}
inline ::google::protobuf::int32 BuyBagSoltRspNet::materialsbag() const {
  // @@protoc_insertion_point(field_get:protocol.BuyBagSoltRspNet.materialsBag)
  return materialsbag_;
}
inline void BuyBagSoltRspNet::set_materialsbag(::google::protobuf::int32 value) {
  set_has_materialsbag();
  materialsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyBagSoltRspNet.materialsBag)
}

// required int32 questsBag = 4;
inline bool BuyBagSoltRspNet::has_questsbag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BuyBagSoltRspNet::set_has_questsbag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BuyBagSoltRspNet::clear_has_questsbag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BuyBagSoltRspNet::clear_questsbag() {
  questsbag_ = 0;
  clear_has_questsbag();
}
inline ::google::protobuf::int32 BuyBagSoltRspNet::questsbag() const {
  // @@protoc_insertion_point(field_get:protocol.BuyBagSoltRspNet.questsBag)
  return questsbag_;
}
inline void BuyBagSoltRspNet::set_questsbag(::google::protobuf::int32 value) {
  set_has_questsbag();
  questsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyBagSoltRspNet.questsBag)
}

// required int32 equipsBag = 5;
inline bool BuyBagSoltRspNet::has_equipsbag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BuyBagSoltRspNet::set_has_equipsbag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BuyBagSoltRspNet::clear_has_equipsbag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BuyBagSoltRspNet::clear_equipsbag() {
  equipsbag_ = 0;
  clear_has_equipsbag();
}
inline ::google::protobuf::int32 BuyBagSoltRspNet::equipsbag() const {
  // @@protoc_insertion_point(field_get:protocol.BuyBagSoltRspNet.equipsBag)
  return equipsbag_;
}
inline void BuyBagSoltRspNet::set_equipsbag(::google::protobuf::int32 value) {
  set_has_equipsbag();
  equipsbag_ = value;
  // @@protoc_insertion_point(field_set:protocol.BuyBagSoltRspNet.equipsBag)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::NetMsgID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NetMsgID>() {
  return ::protocol::NetMsgID_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fmsg_5fnet_2eproto__INCLUDED
